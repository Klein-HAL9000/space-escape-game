<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星际逃亡 - 新版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #fff;
            overflow: hidden;
        }

        #mainContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            display: none; /* 初始隐藏游戏界面 */
        }

        canvas {
            border: 2px solid #333;
            background-color: #000;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
        }

        #levelProgress {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0af;
            border-radius: 10px;
            overflow: hidden;
        }

        #progressBar {
            height: 100%;
            width: 0%;
            background-color: #0af;
            transition: width 0.3s;
        }

        #levelInfo {
            position: absolute;
            top: 35px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
        }

        /* 新的开始界面样式 */
        #startScreen {
            width: 100%;
            height: 100vh;
            background-color: #000;
            border: 2px solid #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        /* 背景星星 */
        .star {
            position: absolute;
            background-color: #fff;
            width: 2px;
            height: 2px;
            border-radius: 50%;
        }

        .title {
            font-size: 60px;
            margin-bottom: 50px;
            color: #0af;
            text-shadow: 0 0 10px #0af, 0 0 20px #0af;
            text-align: center;
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 10px #0af, 0 0 20px #0af;
            }
            to {
                text-shadow: 0 0 15px #0af, 0 0 30px #0af, 0 0 40px #0af;
            }
        }

        .startButton {
            background-color: #0af;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            transition: all 0.3s;
        }

        .startButton:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px #0af;
        }

        .instructionsButton {
            background-color: transparent;
            color: #0af;
            border: 2px solid #0af;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            transition: all 0.3s;
        }

        .instructionsButton:hover {
            background-color: rgba(0, 170, 255, 0.2);
        }

        /* 游戏说明弹窗 */
        #instructionsModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modalContent {
            background-color: #111;
            width: 700px;
            max-width: 90%;
            padding: 30px;
            border: 2px solid #0af;
            border-radius: 10px;
            position: relative;
        }

        .closeButton {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #0af;
            cursor: pointer;
            background: none;
            border: none;
        }

        .instructionsTitle {
            font-size: 28px;
            color: #0af;
            margin-bottom: 20px;
            text-align: center;
        }

        .instructionsText {
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .controlsTable {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .controlsTable th, .controlsTable td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .controlsTable th {
            color: #0af;
        }

        /* 游戏结束界面 */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .gameOverText {
            font-size: 48px;
            color: #f00;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #f00;
        }

        .finalScore {
            font-size: 24px;
            margin-bottom: 30px;
        }

        .restartButton {
            background-color: #0af;
            color: #000;
            border: none;
            padding: 12px 25px;
            font-size: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            transition: all 0.3s;
        }

        .restartButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px #0af;
        }
    </style>
</head>
<body>
    <div id="mainContainer">
        <!-- 开始界面 -->
        <div id="startScreen">
            <!-- 背景星星会在JS中动态生成 -->
            <h1 class="title">星际逃亡</h1>
            <button class="startButton" id="startButton">开始游戏</button>
            <button class="instructionsButton" id="instructionsButton">游戏说明</button>
        </div>

        <!-- 游戏界面 -->
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>

            <div id="ui">
                <div id="score">得分: 0</div>
                <div id="health">生命值: ■■■</div>
                <div id="energy">能量: ■■■■■</div>
                <div id="autopilot">自动驾驶: 关闭</div>
                <div id="gameTime">游戏时间: 0:00</div>
                <div id="speedMultiplier">速度: 1.0x</div>
            </div>

            <div id="levelProgress">
                <div id="progressBar"></div>
            </div>
            <div id="levelInfo">第1关: 太阳系边缘 - 目标: 5000分</div>

            <!-- 游戏结束界面 -->
            <div id="gameOverScreen">
                <div class="gameOverText">游戏结束</div>
                <div class="finalScore">最终得分: <span id="finalScoreValue">0</span></div>
                <button class="restartButton" id="restartButton">重新开始</button>
            </div>
        </div>
    </div>

    <!-- 游戏说明弹窗 -->
    <div id="instructionsModal">
        <div class="modalContent">
            <button class="closeButton" id="closeInstructions">×</button>
            <h2 class="instructionsTitle">游戏说明</h2>
            <div class="instructionsText">
                <p>在第四次世界大战爆发的瞬间，地球文明几乎毁灭殆尽。作为一名星舰舰长，你驾驶最后一艘逃离地球的光速星舰，踏上了寻找新家园的漫长旅程。</p>
                <p>银河系正在坍缩，文明密度急速下降，你需要在资源有限的情况下，穿越危险的宇宙空间，最终找到适合人类生存的新恒星系。</p>
                <p>游戏共有5个关卡，每关有不同的目标分数。达到目标分数并飞行足够距离后进入下一关。</p>
            </div>

            <h3 style="color: #0af;">操作方式</h3>
            <table class="controlsTable">
                <tr>
                    <th>按键</th>
                    <th>功能</th>
                </tr>
                <tr>
                    <td>方向键</td>
                    <td>控制飞船移动</td>
                </tr>
                <tr>
                    <td>空格键</td>
                    <td>切换自动/手动驾驶</td>
                </tr>
            </table>

            <h3 style="color: #0af;">游戏提示</h3>
            <ul class="instructionsText">
                <li>自动驾驶会消耗能量，且不会得分</li>
                <li>手动移动飞船也会消耗能量</li>
                <li>收集绿色能量晶体补充能量</li>
                <li>收集红色修复组件恢复生命</li>
                <li>手动驾驶时间越长，游戏难度越高</li>
                <li>切换自动/手动驾驶需要3秒过渡时间</li>
            </ul>
        </div>
    </div>

    <script>
        // 游戏常量
        const GAME_WIDTH = window.innerWidth - 20; // 减去一点边距
        const GAME_HEIGHT = window.innerHeight - 20;
        const PLAYER_WIDTH = 64;
        const PLAYER_HEIGHT = 64;
        const OBSTACLE_WIDTH = 48;
        const OBSTACLE_HEIGHT = 48;
        const RESOURCE_WIDTH = 32;
        const RESOURCE_HEIGHT = 32;
        const PLAYER_SPEED = 5;
        const BASE_OBSTACLE_SPEED = 3;
        const ENERGY_DRAIN_INTERVAL = 3000; // 每3秒减少一格能量
        const AUTOPILOT_ENERGY_DRAIN = 0.1;
        const MAX_HEALTH = 3;
        const MAX_ENERGY = 10; // 能量上限增加到10格
        const OBSTACLE_SPAWN_RATE = 0.02;
        const ENERGY_RESOURCE_SPAWN_RATE = 0.001;
        const HEALTH_RESOURCE_SPAWN_RATE = 0.005;
        const TRANSITION_TIME = 3; // 自动驾驶切换过渡时间（秒）
        const SPEED_INCREASE_INTERVAL = 1.5; // 每1.5秒增加速度
        const SPEED_INCREASE_AMOUNT = 0.1; // 每次增加0.1倍速度
        const MAX_UNIVERSE_SPEED = 4.0; // 宇宙坍缩速度上限
        const MAX_SPEED_MULTIPLIER = 3.0; // 最大速度倍数
        const MIN_OBSTACLE_DISTANCE = 200; // 障碍物之间的最小距离，增加到200

        // 关卡配置
        const LEVELS = [
            {
                id: 1,
                name: "太阳系边缘",
                description: "刚刚逃离地球，正在穿越太阳系边缘区域。障碍物较少，是熟悉飞船控制的好机会。",
                distance: 10000, // 光年距离（实际是游戏内部计量单位）
                obstacleRate: 0.015, // 障碍物生成率
                resourceRate: {
                    energy: 0.008, // 能量资源生成率
                    health: 0.005  // 生命资源生成率
                },
                enemyRate: 0, // 敌人生成率（暂未实现）
                backgroundStars: 80, // 背景星星数量
                speedMultiplierMax: 2.0, // 最大速度倍数
                specialEffects: [], // 特殊效果（暂未实现）
                bgColor: "#000022", // 背景色
                goalScore: 5000 // 通关所需分数
            },
            {
                id: 2,
                name: "猎户座臂",
                description: "进入猎户座臂区域，这里的小行星和太空碎片明显增多。保持警惕，寻找能量补给。",
                distance: 15000,
                obstacleRate: 0.02,
                resourceRate: {
                    energy: 0.006,
                    health: 0.004
                },
                enemyRate: 0.002,
                backgroundStars: 100,
                speedMultiplierMax: 2.2,
                specialEffects: ["meteorShower"],
                bgColor: "#000033",
                goalScore: 12000
            },
            {
                id: 3,
                name: "银河系中心",
                description: "接近银河系中心区域，这里的黑洞引力影响使飞行变得困难。障碍物密集，资源稀少。",
                distance: 20000,
                obstacleRate: 0.025,
                resourceRate: {
                    energy: 0.004,
                    health: 0.003
                },
                enemyRate: 0.005,
                backgroundStars: 120,
                speedMultiplierMax: 2.5,
                specialEffects: ["gravityWell"],
                bgColor: "#000044",
                goalScore: 20000
            },
            {
                id: 4,
                name: "银河系外围",
                description: "穿越银河系外围区域，这里是外星文明的领地。小心敌对飞船的攻击。",
                distance: 25000,
                obstacleRate: 0.027, // 减少10%障碍物
                resourceRate: {
                    energy: 0.003,
                    health: 0.002
                },
                enemyRate: 0.01,
                backgroundStars: 90,
                speedMultiplierMax: 2.8,
                specialEffects: ["alienEncounter"],
                bgColor: "#000055",
                goalScore: 30000
            },
            {
                id: 5,
                name: "银河系边缘",
                description: "最后的冲刺！银河系边缘充满各种危险，但自由就在眼前。全力以赴，逃离银河系！",
                distance: 30000,
                obstacleRate: 0.0315, // 减少10%障碍物
                resourceRate: {
                    energy: 0.01, // 增加能量补给生成率，原来是0.002
                    health: 0.001
                },
                enemyRate: 0.015,
                backgroundStars: 70,
                speedMultiplierMax: 3.0,
                specialEffects: ["spaceDistortion"],
                bgColor: "#000066",
                goalScore: 50000
            }
        ];

        // 游戏变量
        let canvas, ctx;
        let gameRunning = false;
        let gameScore = 0;
        let playerHealth = MAX_HEALTH;
        let playerEnergy = MAX_ENERGY;
        let autopilotEnabled = false; // 初始状态为手动驾驶
        let autopilotTransitioning = false; // 是否正在切换自动驾驶状态
        let transitionProgress = 0; // 切换进度 (0-1)
        let transitionDirection = 0; // 1=开启自动, -1=关闭自动
        let lastTime = 0;
        let gameTime = 0; // 游戏时间（秒）
        let manualDriveTime = 0; // 手动驾驶累计时间（秒）
        let speedMultiplier = 1.0; // 速度倍数
        let obstacles = [];
        let resources = [];
        let stars = [];
        let particles = []; // 粒子效果
        let keys = {};
        let playerMoving = false; // 玩家是否在移动
        let lastEnergyDrainTime = 0; // 上次能量减少的时间
        let gameStarted = false; // 游戏是否真正开始（飞船超过第一个障碍物）
        let playerInvincible = false; // 玩家是否处于无敌状态
        let invincibleEndTime = 0; // 无敌状态结束时间

        // 关卡5特殊元素
        let trisolaris = null; // 三体星系
        let droplet = null; // 水滴
        let dropletHealth = 20; // 水滴生命值
        let dropletSpawned = false; // 水滴是否已生成
        let dropletSpawnTime = 0; // 水滴生成时间
        let gameEnding = false; // 游戏是否正在结束
        let endingPhase = 0; // 结束动画阶段
        let endingTime = 0; // 结束动画开始时间
        let endingButtonAdded = false; // 是否已添加结束按钮

        // 道具系统
        let hasBarrier = false; // 是否拥有屏障道具
        let hasWavegun = false; // 是否拥有次声波武器
        let barrierActive = false; // 屏障是否激活
        let barrierEndTime = 0; // 屏障结束时间

        // 隐藏的无敌模式
        let godModeEnabled = false; // 是否启用无敌模式

        // 音效
        let collisionSound = null;
        let backgroundMusic = null;
        let explosionSound = null;
        let energySound = null;
        let barrierSound = null;
        let wavegunSound = null;
        let dropletAttackSound = null;

        // 玩家飞船
        const player = {
            x: 100,
            y: GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2,
            width: PLAYER_WIDTH,
            height: PLAYER_HEIGHT,
            color: '#0af',

            draw: function() {
                // 检查无敌状态
                if (playerInvincible) {
                    // 检查是否应该结束无敌状态
                    if (performance.now() > invincibleEndTime) {
                        playerInvincible = false;
                    }

                    // 闪烁效果 - 每100毫秒切换一次可见性
                    if (Math.floor(performance.now() / 100) % 2 === 0) {
                        return; // 跳过绘制，实现闪烁
                    }
                }

                // 绘制像素风格的尾焰效果 - 燃料像素碎片散落效果
                const currentTime = performance.now();

                // 创建一个随机种子，使每帧的随机效果看起来更加连贯
                const randomSeed = Math.floor(currentTime / 50);

                // 根据飞船是否移动调整尾焰强度
                let thrustIntensity = 0.6;  // 默认强度

                // 如果飞船正在移动，增加尾焰强度
                if (playerMoving) {
                    thrustIntensity = 1.0;  // 全强度
                } else if (autopilotEnabled) {
                    thrustIntensity = 0.8;  // 自动驾驶时的强度
                }

                // 引擎脉动效果
                const pulseFactor = 0.8 + Math.sin(currentTime / 100) * 0.2;
                thrustIntensity *= pulseFactor;

                // 绘制引擎核心发光效果
                // 上引擎
                ctx.fillStyle = '#ff3';  // 亮黄色
                ctx.fillRect(this.x, this.y + 20, 5, 5);

                // 下引擎
                ctx.fillStyle = '#ff3';  // 亮黄色
                ctx.fillRect(this.x, this.y + 35, 5, 5);

                // 绘制像素碎片
                // 使用多种颜色创建更丰富的视觉效果
                const colors = ['#f70', '#f50', '#ff3', '#fa0', '#f00'];

                // 计算碎片数量和最大距离，基于推力强度
                const particleCount = Math.floor(8 + thrustIntensity * 8);  // 8-16个粒子
                const maxDistance = 15 + thrustIntensity * 20;  // 15-35像素

                // 为每个引擎创建像素碎片
                // 上引擎碎片
                for (let i = 0; i < particleCount; i++) {
                    // 使用伪随机数，基于位置和时间
                    const rand1 = Math.sin(i * 1.3 + randomSeed * 0.1) * 0.5 + 0.5;
                    const rand2 = Math.cos(i * 2.7 + randomSeed * 0.2) * 0.5 + 0.5;

                    // 计算碎片位置
                    const distance = rand1 * maxDistance;
                    const offsetY = (rand2 - 0.5) * 6;  // 上下偏移±3像素

                    // 计算碎片大小和透明度
                    const size = Math.max(1, Math.floor(3 - distance / 15));  // 越远越小
                    const alpha = Math.max(0.2, 1 - distance / maxDistance) * thrustIntensity;  // 越远越透明

                    // 选择颜色
                    const colorIndex = Math.floor(rand1 * colors.length);
                    ctx.fillStyle = colors[colorIndex];

                    // 绘制碎片
                    ctx.globalAlpha = alpha;
                    ctx.fillRect(
                        this.x - distance,
                        this.y + 22 + offsetY,
                        size,
                        size
                    );
                }

                // 下引擎碎片
                for (let i = 0; i < particleCount; i++) {
                    // 使用伪随机数，基于位置和时间，与上引擎有所不同
                    const rand1 = Math.sin(i * 1.7 + randomSeed * 0.15) * 0.5 + 0.5;
                    const rand2 = Math.cos(i * 2.3 + randomSeed * 0.25) * 0.5 + 0.5;

                    // 计算碎片位置
                    const distance = rand1 * maxDistance;
                    const offsetY = (rand2 - 0.5) * 6;  // 上下偏移±3像素

                    // 计算碎片大小和透明度
                    const size = Math.max(1, Math.floor(3 - distance / 15));  // 越远越小
                    const alpha = Math.max(0.2, 1 - distance / maxDistance) * thrustIntensity;  // 越远越透明

                    // 选择颜色
                    const colorIndex = Math.floor(rand1 * colors.length);
                    ctx.fillStyle = colors[colorIndex];

                    // 绘制碎片
                    ctx.globalAlpha = alpha;
                    ctx.fillRect(
                        this.x - distance,
                        this.y + 37 + offsetY,
                        size,
                        size
                    );
                }

                // 恢复透明度
                ctx.globalAlpha = 1.0;

                // 绘制像素风格的飞船
                ctx.fillStyle = this.color;

                // 飞船主体
                ctx.fillRect(this.x + 20, this.y + 20, 30, 20);

                // 飞船头部
                ctx.fillRect(this.x + 50, this.y + 25, 10, 10);

                // 飞船尾部
                ctx.fillRect(this.x + 10, this.y + 15, 10, 30);

                // 飞船引擎
                ctx.fillStyle = '#f70';
                ctx.fillRect(this.x, this.y + 20, 10, 5);
                ctx.fillRect(this.x, this.y + 35, 10, 5);

                // 飞船窗口
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + 35, this.y + 25, 5, 10);

                // 如果自动驾驶开启或正在切换，绘制蓝色光环
                if (autopilotEnabled || autopilotTransitioning) {
                    let alpha = autopilotEnabled ? 1.0 : transitionProgress;
                    if (transitionDirection < 0) alpha = 1.0 - transitionProgress;

                    ctx.strokeStyle = `rgba(0, 170, 255, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x + 30, this.y + 30, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // 如果处于无敌状态，绘制保护罩
                if (playerInvincible) {
                    const shieldRadius = 40;
                    const gradient = ctx.createRadialGradient(
                        this.x + 30, this.y + 30, shieldRadius - 10,
                        this.x + 30, this.y + 30, shieldRadius
                    );
                    gradient.addColorStop(0, 'rgba(138, 43, 226, 0.1)');
                    gradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.3)');
                    gradient.addColorStop(1, 'rgba(138, 43, 226, 0.1)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x + 30, this.y + 30, shieldRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            update: function(deltaTime) {
                // 重置移动状态
                playerMoving = false;

                // 处理自动驾驶切换
                if (autopilotTransitioning) {
                    transitionProgress += (deltaTime / 1000) / TRANSITION_TIME;
                    if (transitionProgress >= 1) {
                        transitionProgress = 0;
                        autopilotTransitioning = false;
                        if (transitionDirection > 0) {
                            // 完成切换到自动驾驶
                            autopilotEnabled = true;
                        } else {
                            // 完成切换到手动驾驶
                            autopilotEnabled = false;
                        }
                        updateUI();
                    }
                }

                // 手动控制
                if (!autopilotEnabled) {
                    // 设置边界缓冲区，防止飞船部分超出屏幕
                    const minX = 10; // 左边界缓冲
                    const maxX = GAME_WIDTH - PLAYER_WIDTH - 10; // 右边界缓冲
                    const minY = 10; // 上边界缓冲
                    const maxY = GAME_HEIGHT - PLAYER_HEIGHT - 10; // 下边界缓冲

                    // 根据能量状态决定移动速度
                    const moveSpeed = playerEnergy > 0 ? PLAYER_SPEED : PLAYER_SPEED / 2;

                    if (keys['ArrowUp'] && this.y > minY) {
                        this.y -= moveSpeed;
                        playerMoving = true;
                    }
                    if (keys['ArrowDown'] && this.y < maxY) {
                        this.y += moveSpeed;
                        playerMoving = true;
                    }
                    if (keys['ArrowLeft'] && this.x > minX) {
                        this.x -= moveSpeed;
                        playerMoving = true;
                    }
                    if (keys['ArrowRight'] && this.x < maxX) {
                        this.x += moveSpeed;
                        playerMoving = true;
                    }

                    // 强制限制在边界内
                    if (this.x < minX) this.x = minX;
                    if (this.x > maxX) this.x = maxX;
                    if (this.y < minY) this.y = minY;
                    if (this.y > maxY) this.y = maxY;

                    // 如果能量耗尽，记录状态
                    if (playerEnergy <= 0 && playerMoving) {
                        console.log("飞船能量耗尽，移动速度减半...");
                    }
                } else {
                    // 自动驾驶逻辑
                    // 寻找最近的障碍物并尝试避开
                    let nearestObstacle = null;
                    let minDistance = Infinity;

                    for (let obstacle of obstacles) {
                        if (obstacle.x > this.x) {  // 只考虑前方的障碍物
                            const distance = Math.sqrt(
                                Math.pow(obstacle.x - this.x, 2) +
                                Math.pow(obstacle.y - this.y, 2)
                            );

                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestObstacle = obstacle;
                            }
                        }
                    }

                    // 如果有障碍物且距离较近，尝试避开
                    if (nearestObstacle && minDistance < 200) {
                        if (nearestObstacle.y < this.y + PLAYER_HEIGHT / 2) {
                            // 障碍物在上方，向下移动
                            if (this.y < GAME_HEIGHT - PLAYER_HEIGHT) {
                                this.y += PLAYER_SPEED / 2;
                            }
                        } else {
                            // 障碍物在下方，向上移动
                            if (this.y > 0) {
                                this.y -= PLAYER_SPEED / 2;
                            }
                        }
                    } else {
                        // 没有障碍物时，尝试回到中间位置
                        if (Math.abs(this.y - (GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2)) > 5) {
                            if (this.y > GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2) {
                                this.y -= PLAYER_SPEED / 4;
                            } else {
                                this.y += PLAYER_SPEED / 4;
                            }
                        }
                    }

                    // 自动驾驶消耗能量（无敌模式下不消耗）
                    if (!levelManager.isTransitioning && !godModeEnabled) {
                        playerEnergy -= AUTOPILOT_ENERGY_DRAIN / 60 * deltaTime / 16;
                        if (playerEnergy <= 0) {
                            playerEnergy = 0;
                            // 开始切换到手动驾驶
                            startAutopilotTransition(false);
                            updateUI();
                        }
                    }
                }
            }
        };

        // 障碍物类
        class Obstacle {
            constructor() {
                // 随机选择障碍物大小倍数 (1x, 2x, 3x)
                // 获取当前关卡
                const currentLevel = levelManager ? levelManager.getCurrentLevel() : LEVELS[0];

                // 随机选择障碍物类型
                // 0: 小行星, 1: 太空碎片, 2: 恒星, 3: 黑洞, 4: 白洞, 5: 彗星
                const typeRandom = Math.random();

                // 黑洞只在关卡2及以后出现，白洞和彗星只在关卡3及以后出现
                const blackHoleChance = currentLevel.id >= 2 ? 0.04 : 0; // 黑洞概率 (4%)
                const whiteHoleChance = currentLevel.id >= 3 ? 0.04 : 0; // 白洞概率 (4%)
                const cometChance = currentLevel.id >= 3 ? 0.0167 : 0; // 彗星概率 (1.67%，原来是2.5%，再降低1/3)

                // 计算各种障碍物的概率范围
                const asteroidProb = 0.3; // 小行星概率降低到30%
                const debrisProb = 0.6 - blackHoleChance - whiteHoleChance; // 太空碎片概率增加
                const starProb = debrisProb + 0.4; // 恒星概率增加
                const blackHoleProb = starProb + blackHoleChance; // 黑洞概率
                const whiteHoleProb = blackHoleProb + whiteHoleChance; // 白洞概率
                // 彗星概率 = 1.0

                if (typeRandom < asteroidProb) {
                    this.type = 0; // 小行星 (30%)
                    this.sizeMultiplier = Math.floor(Math.random() * 3) + 1;
                    // 随机选择小行星颜色
                    this.asteroidColor = Math.random() < 0.5 ? '#a87' : '#998877';
                } else if (typeRandom < debrisProb) {
                    this.type = 1; // 太空碎片
                    this.sizeMultiplier = Math.floor(Math.random() * 3) + 1;

                    // 为太空碎片添加随机直线运动
                    this.hasRandomMovement = true;
                    this.movementAngle = Math.random() * Math.PI - Math.PI/2; // -90度到90度的角度
                    this.movementSpeed = BASE_OBSTACLE_SPEED * (0.5 + Math.random() * 0.5); // 0.5x到1x的基础速度
                } else if (typeRandom < starProb) {
                    this.type = 2; // 恒星
                    this.sizeMultiplier = Math.floor(Math.random() * 2) + 3; // 恒星更大 (3x-4x)
                } else if (typeRandom < blackHoleProb) {
                    this.type = 3; // 黑洞
                    // 随机选择黑洞大小：正常或一半大小
                    const isSmall = Math.random() < 0.5;
                    this.sizeMultiplier = isSmall ? 1 : 2;
                    this.gravityRadius = OBSTACLE_WIDTH * (isSmall ? 9 : 15); // 引力影响半径，扩大3倍
                    this.eventHorizon = OBSTACLE_WIDTH * (isSmall ? 2.4 : 4.5); // 事件视界半径，扩大3倍
                } else if (typeRandom < whiteHoleProb) {
                    this.type = 4; // 白洞
                    // 随机选择白洞大小：正常或一半大小
                    const isSmall = Math.random() < 0.5;
                    this.sizeMultiplier = isSmall ? 1 : 2;
                    this.repulsionRadius = OBSTACLE_WIDTH * (isSmall ? 9 : 15); // 排斥影响半径，扩大3倍
                    this.eventHorizon = OBSTACLE_WIDTH * (isSmall ? 2.4 : 4.5); // 事件视界半径，扩大3倍
                } else {
                    this.type = 5; // 彗星 (关卡3+: 2.5%)
                    // 随机选择彗星大小：小型、标准或大型
                    const sizeRandom = Math.random();
                    if (sizeRandom < 0.33) {
                        this.sizeMultiplier = 0.5; // 小型彗星
                    } else if (sizeRandom < 0.66) {
                        this.sizeMultiplier = 1; // 标准彗星
                    } else {
                        this.sizeMultiplier = 2; // 大型彗星
                    }

                    // 彗星参数
                    this.cometColor = Math.random() < 0.5 ? '#39f' : '#f55'; // 蓝色或红色
                    this.tailLength = OBSTACLE_WIDTH * (3 + Math.random() * 2); // 尾巴长度

                    // 彗星运动参数
                    // 随机决定彗星飞行方向：从右向左或从左向右
                    this.fromRight = Math.random() < 0.7; // 70%概率从右向左，30%概率从左向右

                    if (this.fromRight) {
                        // 从右向左飞行
                        this.x = GAME_WIDTH; // 从右侧开始
                        this.movementAngle = Math.PI * 0.75 + Math.random() * Math.PI * 0.5; // 135-225度的角度
                    } else {
                        // 从左向右飞行
                        this.x = -this.width; // 从左侧开始
                        this.movementAngle = Math.random() * Math.PI * 0.5 - Math.PI * 0.25; // -45到45度的角度
                    }

                    // 增加彗星速度
                    this.movementSpeed = BASE_OBSTACLE_SPEED * (2.25 + Math.random() * 1.5); // 2.25x-3.75x的基础速度，是原来的1.5倍
                }

                this.width = OBSTACLE_WIDTH * this.sizeMultiplier;
                this.height = OBSTACLE_HEIGHT * this.sizeMultiplier;
                this.x = GAME_WIDTH;
                this.y = Math.random() * (GAME_HEIGHT - this.height);
                this.speed = BASE_OBSTACLE_SPEED * getCurrentSpeedMultiplier();

                // 为恒星添加卫星
                this.satellites = [];
                if (this.type === 2) {
                    // 随机决定卫星数量 (1-3个)，极少数恒星有3颗卫星
                    const satelliteCount = Math.random() < 0.15 ? 3 : (Math.random() < 0.6 ? 2 : 1);

                    // 卫星类型：普通卫星或彗星
                    for (let i = 0; i < satelliteCount; i++) {
                        // 决定是否为彗星 (10%概率)
                        const isComet = Math.random() < 0.1;

                        // 决定卫星颜色 (黄色或灰色)
                        const color = Math.random() < 0.5 ? '#aaa' : '#ff5';

                        // 轨道半径，更合理的范围
                        // 限制最大轨道，避免卫星轨道过大导致重叠
                        const orbitScale = 1.2 + i * 0.8 + Math.random() * 0.3;
                        const radius = (this.width / 2) * orbitScale;

                        // 卫星大小，增大卫星尺寸使碰撞检测更准确
                        const sizeScale = 0.3 + Math.random() * 0.3; // 增大卫星尺寸范围到0.3-0.6
                        const size = OBSTACLE_WIDTH * sizeScale;

                        // 公转速度，彗星更快
                        const speedScale = isComet ? 0.002 + Math.random() * 0.002 : 0.0005 + Math.random() * 0.001;

                        // 椭圆轨道参数 (仅用于彗星)
                        const eccentricity = isComet ? 0.5 + Math.random() * 0.3 : 0;

                        this.satellites.push({
                            radius: radius,
                            size: size,
                            angle: Math.random() * Math.PI * 2, // 初始角度
                            speed: speedScale, // 公转速度
                            isComet: isComet, // 是否为彗星
                            color: color, // 卫星颜色
                            eccentricity: eccentricity, // 椭圆轨道偏心率
                            perihelionAngle: Math.random() * Math.PI * 2 // 近日点角度
                        });
                    }
                }
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;

                // 检查是否与现有障碍物重叠
                let overlapping = true;
                let attempts = 0;
                const maxAttempts = 20; // 增加尝试次数到20次

                // 确保至少有一条通道可以通过
                const minPassageHeight = PLAYER_HEIGHT * 2.0; // 增加通道高度，确保有足够空间通过

                while (overlapping && attempts < maxAttempts) {
                    overlapping = false;

                    // 检查与其他障碍物的重叠
                    for (let obstacle of obstacles) {
                        const dx = this.x - obstacle.x;
                        const dy = this.y - obstacle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // 增加最小距离，防止障碍物过于密集
                        let minDistance = MIN_OBSTACLE_DISTANCE +
                                          (this.sizeMultiplier + obstacle.sizeMultiplier) * 30; // 增加基础间距

                        // 特殊障碍物需要更大的间距
                        // 恒星、黑洞和白洞需要更大的间距
                        if (this.type === 2 || obstacle.type === 2 || // 恒星
                            this.type === 3 || obstacle.type === 3 || // 黑洞
                            this.type === 4 || obstacle.type === 4) { // 白洞
                            minDistance += 100; // 额外增加100的间距
                        }

                        if (distance < minDistance) {
                            overlapping = true;
                            // 重新生成位置，但避免生成在屏幕边缘
                            this.y = Math.random() * (GAME_HEIGHT - this.height - 100) + 50;
                            break;
                        }
                    }

                    // 检查是否堵死通道
                    if (!overlapping && obstacles.length > 0) {
                        // 按x坐标排序，找到附近的障碍物
                        const nearbyObstacles = obstacles.filter(o =>
                            Math.abs(o.x - this.x) < 200
                        ).sort((a, b) => a.y - b.y);

                        // 检查是否有足够大的通道
                        if (nearbyObstacles.length > 0) {
                            let hasPassage = false;

                            // 检查顶部通道
                            if (nearbyObstacles[0].y > minPassageHeight) {
                                hasPassage = true;
                            }

                            // 检查底部通道
                            if (nearbyObstacles[nearbyObstacles.length - 1].y +
                                nearbyObstacles[nearbyObstacles.length - 1].height <
                                GAME_HEIGHT - minPassageHeight) {
                                hasPassage = true;
                            }

                            // 检查中间通道
                            for (let i = 0; i < nearbyObstacles.length - 1; i++) {
                                const gap = nearbyObstacles[i + 1].y -
                                          (nearbyObstacles[i].y + nearbyObstacles[i].height);
                                if (gap > minPassageHeight) {
                                    hasPassage = true;
                                    break;
                                }
                            }

                            // 如果没有通道，重新生成位置
                            if (!hasPassage) {
                                overlapping = true;
                                this.y = Math.random() * (GAME_HEIGHT - this.height - 100) + 50;
                            }
                        }
                    }

                    attempts++;
                }

                // 如果多次尝试后仍然重叠，则放弃生成这个障碍物
                if (overlapping && attempts >= maxAttempts) {
                    this.width = 0;
                    this.height = 0;
                    this.x = -100; // 放在屏幕外，下一帧会被移除
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);

                if (this.type === 0) {
                    // 小行星 - 使用随机颜色
                    const mainColor = this.asteroidColor || '#a87'; // 如果没有设置颜色，使用默认棕色
                    ctx.fillStyle = mainColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();

                    // 添加一些陨石表面细节 - 根据主色调调整
                    // 计算深色和更深色
                    let detailColor1, detailColor2;
                    if (mainColor === '#a87') {
                        detailColor1 = '#765';
                        detailColor2 = '#654';
                    } else {
                        detailColor1 = '#776655';
                        detailColor2 = '#554433';
                    }

                    ctx.fillStyle = detailColor1;
                    ctx.beginPath();
                    ctx.arc(-this.width/6, -this.height/6, this.width/6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = detailColor2;
                    ctx.beginPath();
                    ctx.arc(this.width/5, this.height/5, this.width/8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 1) {
                    // 太空碎片
                    ctx.fillStyle = '#888';
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, -this.height/2);
                    ctx.lineTo(this.width/2, -this.height/6);
                    ctx.lineTo(0, this.height/2);
                    ctx.closePath();
                    ctx.fill();

                    // 添加一些碎片细节
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.moveTo(-this.width/4, -this.height/4);
                    ctx.lineTo(this.width/4, -this.height/8);
                    ctx.lineTo(0, this.height/4);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 2) {
                    // 恒星
                    // 绘制恒星光晕
                    const gradient = ctx.createRadialGradient(0, 0, this.width/4, 0, 0, this.width/2);
                    gradient.addColorStop(0, '#ff5');
                    gradient.addColorStop(0.7, '#f70');
                    gradient.addColorStop(1, 'rgba(255, 70, 0, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();

                    // 恒星核心
                    ctx.fillStyle = '#ff5';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/3, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制卫星
                    for (let satellite of this.satellites) {
                        let satelliteX, satelliteY;

                        if (satellite.isComet) {
                            // 彗星使用椭圆轨道
                            // 计算椭圆轨道上的位置
                            const a = satellite.radius; // 半长轴
                            const c = a * satellite.eccentricity; // 焦距
                            const b = Math.sqrt(a * a - c * c); // 半短轴

                            // 调整角度，使彗星在近日点时速度更快
                            const adjustedAngle = satellite.angle + satellite.perihelionAngle;

                            // 计算椭圆上的点
                            satelliteX = a * Math.cos(adjustedAngle);
                            satelliteY = b * Math.sin(adjustedAngle);

                            // 绘制椭圆轨道
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();

                            // 绘制椭圆
                            for (let i = 0; i < 360; i += 5) {
                                const angle = i * Math.PI / 180 + satellite.perihelionAngle;
                                const x = a * Math.cos(angle);
                                const y = b * Math.sin(angle);

                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }

                            ctx.closePath();
                            ctx.stroke();

                            // 绘制彗星
                            // 彗星核心
                            ctx.fillStyle = satellite.color;
                            ctx.beginPath();
                            ctx.arc(satelliteX, satelliteY, satellite.size, 0, Math.PI * 2);
                            ctx.fill();

                            // 彗星尾巴 - 总是指向远离恒星的方向
                            const tailLength = satellite.size * 4;
                            const tailAngle = Math.atan2(satelliteY, satelliteX) + Math.PI;

                            const tailEndX = satelliteX + Math.cos(tailAngle) * tailLength;
                            const tailEndY = satelliteY + Math.sin(tailAngle) * tailLength;

                            // 绘制彗星尾巴
                            const tailGradient = ctx.createLinearGradient(
                                satelliteX, satelliteY, tailEndX, tailEndY
                            );
                            tailGradient.addColorStop(0, satellite.color);
                            tailGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.fillStyle = tailGradient;
                            ctx.beginPath();
                            ctx.moveTo(satelliteX, satelliteY);

                            // 尾巴宽度
                            const tailWidth = satellite.size * 0.8;
                            const perpAngle = tailAngle + Math.PI/2;

                            // 尾巴两侧的点
                            const tailSideX1 = satelliteX + Math.cos(perpAngle) * tailWidth;
                            const tailSideY1 = satelliteY + Math.sin(perpAngle) * tailWidth;
                            const tailSideX2 = satelliteX - Math.cos(perpAngle) * tailWidth;
                            const tailSideY2 = satelliteY - Math.sin(perpAngle) * tailWidth;

                            ctx.moveTo(tailSideX1, tailSideY1);
                            ctx.lineTo(tailEndX, tailEndY);
                            ctx.lineTo(tailSideX2, tailSideY2);
                            ctx.closePath();
                            ctx.fill();
                        } else {
                            // 普通卫星使用圆形轨道
                            satelliteX = Math.cos(satellite.angle) * satellite.radius;
                            satelliteY = Math.sin(satellite.angle) * satellite.radius;

                            // 绘制卫星轨道
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(0, 0, satellite.radius, 0, Math.PI * 2);
                            ctx.stroke();

                            // 绘制卫星
                            ctx.fillStyle = satellite.color;
                            ctx.beginPath();
                            ctx.arc(satelliteX, satelliteY, satellite.size, 0, Math.PI * 2);
                            ctx.fill();

                            // 卫星表面细节
                            ctx.fillStyle = satellite.color === '#aaa' ? '#888' : '#fd5';
                            ctx.beginPath();
                            ctx.arc(satelliteX - satellite.size/3, satelliteY - satellite.size/3,
                                    satellite.size/3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } else if (this.type === 3) {
                    // 黑洞
                    // 绘制引力场
                    const gravityGradient = ctx.createRadialGradient(0, 0, this.width/2, 0, 0, this.gravityRadius);
                    gravityGradient.addColorStop(0, 'rgba(75, 0, 130, 0.7)');
                    gravityGradient.addColorStop(0.3, 'rgba(75, 0, 130, 0.4)');
                    gravityGradient.addColorStop(0.7, 'rgba(75, 0, 130, 0.2)');
                    gravityGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

                    ctx.fillStyle = gravityGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.gravityRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制事件视界
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.eventHorizon, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制黑洞中心
                    const holeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                    holeGradient.addColorStop(0, '#000');
                    holeGradient.addColorStop(0.7, '#000');
                    holeGradient.addColorStop(0.9, 'rgba(75, 0, 130, 0.8)');
                    holeGradient.addColorStop(1, 'rgba(75, 0, 130, 0.5)');

                    ctx.fillStyle = holeGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制吸积盘
                    ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/1.5, 0, Math.PI * 2);
                    ctx.stroke();

                    // 绘制光线扭曲效果
                    const angle = this.rotation * 2;
                    for (let i = 0; i < 8; i++) {
                        const rayAngle = angle + i * Math.PI / 4;
                        const rayLength = this.width * 0.8;

                        ctx.strokeStyle = 'rgba(138, 43, 226, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(
                            Math.cos(rayAngle) * rayLength * 0.5,
                            Math.sin(rayAngle) * rayLength * 0.5,
                            Math.cos(rayAngle + 0.5) * rayLength,
                            Math.sin(rayAngle + 0.5) * rayLength
                        );
                        ctx.stroke();
                    }
                } else if (this.type === 4) {
                    // 白洞
                    // 绘制排斥场
                    const repulsionGradient = ctx.createRadialGradient(0, 0, this.width/2, 0, 0, this.repulsionRadius);
                    repulsionGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    repulsionGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
                    repulsionGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.2)');
                    repulsionGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = repulsionGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.repulsionRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制事件视界
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.eventHorizon, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制白洞中心
                    const holeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                    holeGradient.addColorStop(0, '#fff');
                    holeGradient.addColorStop(0.7, '#fff');
                    holeGradient.addColorStop(0.9, 'rgba(200, 200, 255, 0.8)');
                    holeGradient.addColorStop(1, 'rgba(200, 200, 255, 0.5)');

                    ctx.fillStyle = holeGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制光环
                    ctx.strokeStyle = 'rgba(135, 206, 250, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/1.5, 0, Math.PI * 2);
                    ctx.stroke();

                    // 绘制光线发散效果
                    const angle = -this.rotation * 2; // 与黑洞相反的旋转
                    for (let i = 0; i < 8; i++) {
                        const rayAngle = angle + i * Math.PI / 4;
                        const rayLength = this.width * 1.2;

                        ctx.strokeStyle = 'rgba(135, 206, 250, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(
                            Math.cos(rayAngle) * rayLength,
                            Math.sin(rayAngle) * rayLength
                        );
                        ctx.stroke();
                    }
                } else if (this.type === 5) {
                    // 彗星
                    // 彗星核心
                    ctx.fillStyle = this.cometColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();

                    // 彗星尾巴 - 根据飞行方向决定尾巴方向
                    let tailEndX, tailEndY;
                    if (this.fromRight) {
                        // 从右向左飞行，尾巴指向右侧
                        tailEndX = this.tailLength;
                        tailEndY = 0;
                    } else {
                        // 从左向右飞行，尾巴指向左侧
                        tailEndX = -this.tailLength;
                        tailEndY = 0;
                    }

                    // 绘制彗星尾巴
                    const tailGradient = ctx.createLinearGradient(0, 0, tailEndX, tailEndY);
                    tailGradient.addColorStop(0, this.cometColor);
                    tailGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = tailGradient;
                    ctx.beginPath();

                    // 尾巴宽度
                    const tailWidth = this.width * 0.8;

                    // 尾巴两侧的点
                    const tailSideY1 = tailWidth/2;
                    const tailSideY2 = -tailWidth/2;

                    ctx.moveTo(0, tailSideY1);
                    ctx.lineTo(tailEndX, tailEndY + tailWidth/4);
                    ctx.lineTo(tailEndX, tailEndY - tailWidth/4);
                    ctx.lineTo(0, tailSideY2);
                    ctx.closePath();
                    ctx.fill();

                    // 绘制事件视界
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.eventHorizon, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制白洞中心
                    const holeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                    holeGradient.addColorStop(0, '#fff');
                    holeGradient.addColorStop(0.7, '#fff');
                    holeGradient.addColorStop(0.9, 'rgba(200, 200, 255, 0.8)');
                    holeGradient.addColorStop(1, 'rgba(200, 200, 255, 0.5)');

                    ctx.fillStyle = holeGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();

                    // 绘制光环
                    ctx.strokeStyle = 'rgba(135, 206, 250, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/1.5, 0, Math.PI * 2);
                    ctx.stroke();

                    // 绘制光线发散效果
                    const angle = -this.rotation * 2; // 与黑洞相反的旋转
                    for (let i = 0; i < 8; i++) {
                        const rayAngle = angle + i * Math.PI / 4;
                        const rayLength = this.width * 1.2;

                        ctx.strokeStyle = 'rgba(135, 206, 250, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(
                            Math.cos(rayAngle) * rayLength,
                            Math.sin(rayAngle) * rayLength
                        );
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            update(deltaTime) {
                // 基本移动
                this.x -= this.speed;
                this.rotation += this.rotationSpeed;

                // 太空碎片的随机直线运动
                if (this.type === 1 && this.hasRandomMovement) {
                    // 根据角度计算垂直方向的移动
                    this.y += Math.sin(this.movementAngle) * this.movementSpeed;

                    // 不再反弹，让碎片自然飞出屏幕
                    // 标记为移除的条件会在外部检查
                }

                // 彗星的直线运动
                if (this.type === 5) {
                    // 根据飞行方向和角度更新位置
                    if (this.fromRight) {
                        // 从右向左飞行
                        this.x -= this.movementSpeed;
                    } else {
                        // 从左向右飞行
                        this.x += this.movementSpeed;
                    }

                    // 根据角度决定垂直方向的移动
                    this.y += Math.sin(this.movementAngle) * this.movementSpeed * 0.5;

                    // 不反弹，让彗星自然飞出屏幕
                }

                // 更新卫星位置和检测碰撞
                if (this.type === 2 && gameStarted) {
                    for (let satellite of this.satellites) {
                        // 更新角度
                        satellite.angle += satellite.speed * deltaTime;

                        // 计算卫星的实际位置
                        let satelliteX, satelliteY;

                        if (satellite.isComet) {
                            // 彗星使用椭圆轨道
                            const a = satellite.radius; // 半长轴
                            const c = a * satellite.eccentricity; // 焦距
                            const b = Math.sqrt(a * a - c * c); // 半短轴

                            // 调整角度
                            const adjustedAngle = satellite.angle + satellite.perihelionAngle;

                            // 计算椭圆上的点
                            satelliteX = a * Math.cos(adjustedAngle);
                            satelliteY = b * Math.sin(adjustedAngle);
                        } else {
                            // 普通卫星使用圆形轨道
                            satelliteX = Math.cos(satellite.angle) * satellite.radius;
                            satelliteY = Math.sin(satellite.angle) * satellite.radius;
                        }

                        // 转换为全局坐标
                        const globalX = this.x + this.width/2 + satelliteX;
                        const globalY = this.y + this.height/2 + satelliteY;

                        // 检查与飞船的碰撞
                        if (!playerInvincible && !godModeEnabled) {
                            const dx = globalX - (player.x + player.width/2);
                            const dy = globalY - (player.y + player.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            // 如果碰撞 - 使用更精确的碰撞检测
                            if (distance < satellite.size + player.width/2 * 0.9) { // 增大碰撞检测范围
                                // 如果屏障激活，抵挡伤害
                                if (barrierActive) {
                                    // 创建屏障抵挡效果
                                    createExplosion(
                                        player.x + player.width/2,
                                        player.y + player.height/2,
                                        30,
                                        '#0af' // 蓝色
                                    );

                                    // 只有在非无敌模式下才关闭屏障
                                    if (!godModeEnabled) {
                                        // 关闭屏障
                                        barrierActive = false;

                                        // 移除屏障技能图标
                                        const barrierSkill = document.getElementById('barrierSkill');
                                        if (barrierSkill) {
                                            barrierSkill.remove();
                                        }
                                    }
                                } else {
                                    // 减少生命值
                                    playerHealth--;
                                    updateUI();

                                    // 创建碰撞效果 - 在卫星位置创建爆炸
                                    createExplosion(
                                        globalX,
                                        globalY,
                                        satellite.size * 2,
                                        satellite.color
                                    );

                                    // 在飞船位置创建爆炸
                                    createExplosion(
                                        player.x + player.width/2,
                                        player.y + player.height/2,
                                        30,
                                        '#aaa' // 银灰色
                                    );

                                    if (playerHealth <= 0) {
                                        gameOver();
                                        return;
                                    }

                                    // 设置飞船无敌状态
                                    playerInvincible = true;
                                    invincibleEndTime = performance.now() + 3000; // 3秒无敌时间
                                }
                            }
                        }
                    }
                }

                // 黑洞引力效果
                if (this.type === 3 && gameStarted) {
                    const holeX = this.x + this.width/2;
                    const holeY = this.y + this.height/2;

                    // 对飞船施加引力（如果不处于无敌状态、不是无敌模式且没有屏障）
                    if (!playerInvincible && !godModeEnabled && !barrierActive) {
                        // 计算飞船与黑洞中心的距离
                        const dx = holeX - (player.x + player.width/2);
                        const dy = holeY - (player.y + player.height/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // 如果在引力范围内，施加引力
                        if (distance < this.gravityRadius) {
                            // 引力强度与距离成反比，增加引力强度
                            const gravityStrength = 1.2 * (1 - distance / this.gravityRadius);

                            // 计算引力方向
                            const dirX = dx / distance;
                            const dirY = dy / distance;

                            // 施加引力（移动飞船向黑洞）
                            player.x += dirX * gravityStrength * PLAYER_SPEED;
                            player.y += dirY * gravityStrength * PLAYER_SPEED;

                            // 强制限制飞船在屏幕内
                            const minX = 10;
                            const maxX = GAME_WIDTH - player.width - 10;
                            const minY = 10;
                            const maxY = GAME_HEIGHT - player.height - 10;

                            if (player.x < minX) player.x = minX;
                            if (player.x > maxX) player.x = maxX;
                            if (player.y < minY) player.y = minY;
                            if (player.y > maxY) player.y = maxY;

                            // 如果进入事件视界，飞船被吸入黑洞
                            if (distance < this.eventHorizon) {
                                this.absorbPlayer();
                            }
                        }
                    }

                    // 对周围的障碍物施加引力
                    for (let i = 0; i < obstacles.length; i++) {
                        // 跳过自己和其他黑洞/白洞
                        if (obstacles[i] === this || obstacles[i].type === 3 || obstacles[i].type === 4) {
                            continue;
                        }

                        // 只对小行星和太空碎片施加引力
                        if (obstacles[i].type <= 1) {
                            const obstacleX = obstacles[i].x + obstacles[i].width/2;
                            const obstacleY = obstacles[i].y + obstacles[i].height/2;

                            const dx = holeX - obstacleX;
                            const dy = holeY - obstacleY;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            // 如果在引力范围内
                            if (distance < this.gravityRadius) {
                                // 引力强度与距离成反比
                                const gravityStrength = 0.3 * (1 - distance / this.gravityRadius);

                                // 计算引力方向
                                const dirX = dx / distance;
                                const dirY = dy / distance;

                                // 施加引力（移动障碍物）
                                obstacles[i].x += dirX * gravityStrength * BASE_OBSTACLE_SPEED;
                                obstacles[i].y += dirY * gravityStrength * BASE_OBSTACLE_SPEED;

                                // 如果障碍物进入事件视界，将其吸收（移除）
                                if (distance < this.eventHorizon) {
                                    // 创建吸收效果
                                    createExplosion(
                                        obstacleX,
                                        obstacleY,
                                        10, // 较少的粒子
                                        '#8a2be2' // 紫色
                                    );

                                    // 标记为移除
                                    obstacles[i].markedForRemoval = true;
                                }
                            }
                        }
                    }
                }

                // 白洞排斥效果
                if (this.type === 4 && !playerInvincible && !godModeEnabled && !barrierActive && gameStarted) {
                    const holeX = this.x + this.width/2;
                    const holeY = this.y + this.height/2;

                    // 计算飞船与白洞中心的距离
                    const dx = holeX - (player.x + player.width/2);
                    const dy = holeY - (player.y + player.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // 如果在排斥范围内，施加排斥力
                    if (distance < this.repulsionRadius) {
                        // 如果进入事件视界，飞船被弹开
                        if (distance < this.eventHorizon) {
                            this.repulsePlayer();
                        } else {
                            // 排斥强度与距离成反比
                            const repulsionStrength = 0.8 * (1 - distance / this.repulsionRadius);

                            // 计算排斥方向（与引力相反）
                            const dirX = dx / distance;
                            const dirY = dy / distance;

                            // 施加排斥力（移动飞船远离白洞）
                            player.x -= dirX * repulsionStrength * PLAYER_SPEED * 1.5;
                            player.y -= dirY * repulsionStrength * PLAYER_SPEED * 1.5;

                            // 强制限制飞船在屏幕内
                            const minX = 10;
                            const maxX = GAME_WIDTH - player.width - 10;
                            const minY = 10;
                            const maxY = GAME_HEIGHT - player.height - 10;

                            if (player.x < minX) player.x = minX;
                            if (player.x > maxX) player.x = maxX;
                            if (player.y < minY) player.y = minY;
                            if (player.y > maxY) player.y = maxY;
                        }
                    }
                }

                // 如果超出屏幕，返回true以移除
                return this.x + this.width < 0;
            }

            // 黑洞吸收飞船
            absorbPlayer() {
                // 如果飞船处于无敌状态、无敌模式或屏障激活，不会被吸收
                if (playerInvincible || godModeEnabled || barrierActive) {
                    // 如果屏障激活，创建屏障抵挡效果
                    if (barrierActive) {
                        // 创建屏障抵挡效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            30,
                            '#0af' // 蓝色
                        );

                        // 只有在非无敌模式下才关闭屏障
                        if (!godModeEnabled) {
                            // 关闭屏障
                            barrierActive = false;

                            // 移除屏障技能图标
                            const barrierSkill = document.getElementById('barrierSkill');
                            if (barrierSkill) {
                                barrierSkill.remove();
                            }
                        }
                    }
                    return;
                }

                // 减少生命值
                playerHealth -= 1; // 从-2改为-1
                updateUI();

                // 创建黑洞吸收效果
                createExplosion(
                    player.x + player.width/2,
                    player.y + player.height/2,
                    50, // 粒子数量
                    '#8a2be2' // 紫色
                );

                if (playerHealth <= 0) {
                    // 游戏结束
                    gameOver();
                    return;
                }

                // 设置飞船无敌状态
                playerInvincible = true;
                invincibleEndTime = performance.now() + 3000; // 3秒无敌时间

                // 将飞船传送到黑洞前方
                player.x = this.x + this.width + 100;
                player.y = GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2;
            }

            // 白洞排斥飞船
            repulsePlayer() {
                // 如果飞船处于无敌状态、无敌模式或屏障激活，不会被排斥
                if (playerInvincible || godModeEnabled || barrierActive) {
                    // 如果屏障激活，创建屏障抵挡效果
                    if (barrierActive) {
                        // 创建屏障抵挡效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            30,
                            '#0af' // 蓝色
                        );

                        // 只有在非无敌模式下才关闭屏障
                        if (!godModeEnabled) {
                            // 关闭屏障
                            barrierActive = false;

                            // 移除屏障技能图标
                            const barrierSkill = document.getElementById('barrierSkill');
                            if (barrierSkill) {
                                barrierSkill.remove();
                            }
                        }
                    }
                    return;
                }

                // 减少生命值
                playerHealth -= 1; // 从-2改为-1
                updateUI();

                // 创建白洞排斥效果
                createExplosion(
                    player.x + player.width/2,
                    player.y + player.height/2,
                    50, // 粒子数量
                    '#ffffff' // 白色
                );

                if (playerHealth <= 0) {
                    // 游戏结束
                    gameOver();
                    return;
                }

                // 设置飞船无敌状态
                playerInvincible = true;
                invincibleEndTime = performance.now() + 3000; // 3秒无敌时间

                // 将飞船弹到屏幕上边缘或下边缘（取决于当前位置）
                if (player.y < GAME_HEIGHT / 2) {
                    // 如果在上半部分，推到上边缘
                    player.y = player.height;
                } else {
                    // 如果在下半部分，推到下边缘
                    player.y = GAME_HEIGHT - player.height * 2;
                }
                // 保持x坐标不变，但确保在屏幕内
                player.x = Math.max(50, Math.min(GAME_WIDTH - player.width - 50, player.x));
            }

            checkCollision(entity) {
                // 简化的圆形碰撞检测
                const dx = (this.x + this.width/2) - (entity.x + entity.width/2);
                const dy = (this.y + this.height/2) - (entity.y + entity.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 根据障碍物类型调整碰撞半径
                let collisionFactor = 0.8; // 默认碰撞因子

                // 恒星使用更精确的碰撞检测
                if (this.type === 2) {
                    collisionFactor = 0.7; // 恒星的碰撞半径调整为0.7，提高碰撞精度
                }

                const minDistance = (this.width + entity.width) / 2 * collisionFactor;

                return distance < minDistance;
            }
        }

        // 资源类
        class Resource {
            constructor(type) {
                this.width = RESOURCE_WIDTH;
                this.height = RESOURCE_HEIGHT;
                this.x = GAME_WIDTH;
                this.y = Math.random() * (GAME_HEIGHT - this.height);
                this.speed = BASE_OBSTACLE_SPEED * getCurrentSpeedMultiplier();
                this.type = type !== undefined ? type : Math.floor(Math.random() * 2); // 0: 能量, 1: 生命, 2: 屏障, 3: 次声波武器
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.03;

                // 特殊道具的发光效果
                this.glowSize = 0;
                this.glowDirection = 1;
                this.glowSpeed = 0.2 + Math.random() * 0.3;

                // 检查是否与现有障碍物重叠
                let overlapping = true;
                let attempts = 0;
                const maxAttempts = 10;

                while (overlapping && attempts < maxAttempts) {
                    overlapping = false;
                    for (let obstacle of obstacles) {
                        const dx = this.x - obstacle.x;
                        const dy = this.y - obstacle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < MIN_OBSTACLE_DISTANCE / 2) {
                            overlapping = true;
                            // 重新生成位置
                            this.y = Math.random() * (GAME_HEIGHT - this.height);
                            break;
                        }
                    }
                    attempts++;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);

                // 更新发光效果
                if (this.type >= 2) {
                    this.glowSize += this.glowDirection * this.glowSpeed;
                    if (this.glowSize > 5) {
                        this.glowDirection = -1;
                    } else if (this.glowSize < 0) {
                        this.glowDirection = 1;
                    }
                }

                if (this.type === 0) {
                    // 能量晶体
                    ctx.fillStyle = '#0f0';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height/2);
                    ctx.lineTo(this.width/2, 0);
                    ctx.lineTo(0, this.height/2);
                    ctx.lineTo(-this.width/2, 0);
                    ctx.closePath();
                    ctx.fill();

                    // 晶体内部
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height/4);
                    ctx.lineTo(this.width/4, 0);
                    ctx.lineTo(0, this.height/4);
                    ctx.lineTo(-this.width/4, 0);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 1) {
                    // 生命修复
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();

                    // 十字标记
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-this.width/6, -this.height/3, this.width/3, this.height*2/3);
                    ctx.fillRect(-this.width/3, -this.height/6, this.width*2/3, this.height/3);
                } else if (this.type === 2) {
                    // 屏障道具 - 蓝色发光圆形
                    // 外部发光效果
                    const gradient = ctx.createRadialGradient(0, 0, this.width/4, 0, 0, this.width/2 + this.glowSize);
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(0.3, '#0af');
                    gradient.addColorStop(1, 'rgba(0, 170, 255, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2 + this.glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    // 内部白色圆形
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/4, 0, Math.PI * 2);
                    ctx.fill();

                    // 屏障图案
                    ctx.strokeStyle = '#0af';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/3, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (this.type === 3) {
                    // 次声波武器 - 紫色发光圆形
                    // 外部发光效果
                    const gradient = ctx.createRadialGradient(0, 0, this.width/4, 0, 0, this.width/2 + this.glowSize);
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(0.3, '#a0f');
                    gradient.addColorStop(1, 'rgba(170, 0, 255, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2 + this.glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    // 内部白色圆形
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/4, 0, Math.PI * 2);
                    ctx.fill();

                    // 声波图案
                    ctx.strokeStyle = '#a0f';
                    ctx.lineWidth = 2;

                    // 绘制三个同心圆表示声波
                    for (let i = 1; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.arc(0, 0, this.width/3 * i/3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            update(deltaTime) {
                this.x -= this.speed;
                this.rotation += this.rotationSpeed;
                return this.x + this.width < 0; // 返回是否超出屏幕
            }

            checkCollision(entity) {
                return (
                    this.x < entity.x + entity.width &&
                    this.x + this.width > entity.x &&
                    this.y < entity.y + entity.height &&
                    this.y + this.height > entity.y
                );
            }
        }

        // 星星背景
        class Star {
            constructor() {
                this.x = Math.random() * GAME_WIDTH;
                this.y = Math.random() * GAME_HEIGHT;
                this.size = Math.random() * 3 + 1;
                this.baseSpeed = Math.random() * 3 + 1;
                this.brightness = Math.random();
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }

            update(deltaTime) {
                // 星星移动速度也受当前速度倍数影响
                this.x -= this.baseSpeed * getCurrentSpeedMultiplier();
                if (this.x < 0) {
                    this.x = GAME_WIDTH;
                    this.y = Math.random() * GAME_HEIGHT;
                }
            }
        }

        // 三体星系
        class Trisolaris {
            constructor() {
                // 三颗恒星
                this.stars = [
                    {
                        x: GAME_WIDTH * 0.7,
                        y: GAME_HEIGHT * 0.3,
                        size: 80,
                        color: '#ff5',
                        mass: 1.2,
                        vx: 0.2,
                        vy: 0.1
                    },
                    {
                        x: GAME_WIDTH * 0.8,
                        y: GAME_HEIGHT * 0.5,
                        size: 70,
                        color: '#f70',
                        mass: 1.0,
                        vx: -0.15,
                        vy: 0.25
                    },
                    {
                        x: GAME_WIDTH * 0.75,
                        y: GAME_HEIGHT * 0.7,
                        size: 90,
                        color: '#f55',
                        mass: 1.5,
                        vx: 0.1,
                        vy: -0.2
                    }
                ];

                // 引力范围
                this.gravityRadius = 250;
                this.gravityStrength = 1.2;

                // 引力常数
                this.G = 0.01;

                // 边界缓冲区
                this.boundaryBuffer = 50;

                // 上次计算时间
                this.lastTime = performance.now();

                // 混沌因子 - 随机扰动
                this.chaosFactor = 0.001;
            }

            update(deltaTime) {
                // 计算时间步长
                const dt = Math.min(deltaTime / 16, 2); // 限制最大时间步长，防止大幅跳跃

                // 计算恒星之间的引力并更新速度
                for (let i = 0; i < this.stars.length; i++) {
                    const star1 = this.stars[i];

                    // 引力合力
                    let totalForceX = 0;
                    let totalForceY = 0;

                    // 计算其他恒星对当前恒星的引力
                    for (let j = 0; j < this.stars.length; j++) {
                        if (i === j) continue; // 跳过自身

                        const star2 = this.stars[j];

                        // 计算距离
                        const dx = star2.x - star1.x;
                        const dy = star2.y - star1.y;
                        const distSq = dx * dx + dy * dy;
                        const dist = Math.sqrt(distSq);

                        // 防止距离过近导致引力过大
                        const minDist = (star1.size + star2.size) * 0.75;
                        if (dist < minDist) {
                            // 如果恒星过近，添加排斥力
                            const repulsionForce = 0.1 * (minDist - dist) / minDist;
                            totalForceX -= dx / dist * repulsionForce;
                            totalForceY -= dy / dist * repulsionForce;
                            continue;
                        }

                        // 计算引力大小 (F = G * m1 * m2 / r^2)
                        const forceMagnitude = this.G * star1.mass * star2.mass / distSq;

                        // 分解为x和y方向的分力
                        totalForceX += dx / dist * forceMagnitude;
                        totalForceY += dy / dist * forceMagnitude;
                    }

                    // 添加混沌因子 - 随机扰动
                    if (Math.random() < this.chaosFactor * dt) {
                        totalForceX += (Math.random() - 0.5) * 0.5;
                        totalForceY += (Math.random() - 0.5) * 0.5;
                    }

                    // 根据F=ma计算加速度，并更新速度
                    const ax = totalForceX / star1.mass;
                    const ay = totalForceY / star1.mass;

                    star1.vx += ax * dt;
                    star1.vy += ay * dt;

                    // 限制最大速度，防止恒星移动过快
                    const maxSpeed = 0.8;
                    const currentSpeed = Math.sqrt(star1.vx * star1.vx + star1.vy * star1.vy);
                    if (currentSpeed > maxSpeed) {
                        star1.vx = (star1.vx / currentSpeed) * maxSpeed;
                        star1.vy = (star1.vy / currentSpeed) * maxSpeed;
                    }
                }

                // 更新恒星位置
                for (let star of this.stars) {
                    star.x += star.vx * dt;
                    star.y += star.vy * dt;

                    // 边界检查 - 反弹效果
                    const minX = GAME_WIDTH * 0.6 + this.boundaryBuffer;
                    const maxX = GAME_WIDTH - star.size - this.boundaryBuffer;
                    const minY = star.size + this.boundaryBuffer;
                    const maxY = GAME_HEIGHT - star.size - this.boundaryBuffer;

                    // 如果接近边界，施加反向力
                    if (star.x < minX) {
                        star.vx += 0.05 * (minX - star.x) / this.boundaryBuffer;
                    } else if (star.x > maxX) {
                        star.vx -= 0.05 * (star.x - maxX) / this.boundaryBuffer;
                    }

                    if (star.y < minY) {
                        star.vy += 0.05 * (minY - star.y) / this.boundaryBuffer;
                    } else if (star.y > maxY) {
                        star.vy -= 0.05 * (star.y - maxY) / this.boundaryBuffer;
                    }

                    // 硬边界限制，防止恒星完全离开屏幕
                    if (star.x < GAME_WIDTH * 0.6) star.x = GAME_WIDTH * 0.6;
                    if (star.x > GAME_WIDTH - star.size) star.x = GAME_WIDTH - star.size;
                    if (star.y < star.size) star.y = star.size;
                    if (star.y > GAME_HEIGHT - star.size) star.y = GAME_HEIGHT - star.size;
                }

                // 对飞船施加引力
                if (!playerInvincible && !godModeEnabled && !barrierActive) {
                    for (let star of this.stars) {
                        const dx = star.x - (player.x + player.width/2);
                        const dy = star.y - (player.y + player.height/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.gravityRadius) {
                            // 引力强度与距离成反比
                            const gravity = this.gravityStrength * (1 - distance / this.gravityRadius);

                            // 计算引力方向
                            const dirX = dx / distance;
                            const dirY = dy / distance;

                            // 施加引力
                            player.x += dirX * gravity * PLAYER_SPEED;
                            player.y += dirY * gravity * PLAYER_SPEED;

                            // 强制限制飞船在屏幕内
                            const minX = 10;
                            const maxX = GAME_WIDTH - player.width - 10;
                            const minY = 10;
                            const maxY = GAME_HEIGHT - player.height - 10;

                            if (player.x < minX) player.x = minX;
                            if (player.x > maxX) player.x = maxX;
                            if (player.y < minY) player.y = minY;
                            if (player.y > maxY) player.y = maxY;

                            // 检查碰撞
                            if (distance < star.size/2 + player.width/2) {
                                this.hitPlayer();
                            }
                        }
                    }
                }
            }

            draw() {
                for (let star of this.stars) {
                    // 绘制引力场
                    const gradient = ctx.createRadialGradient(
                        star.x, star.y, star.size/4,
                        star.x, star.y, star.size
                    );
                    gradient.addColorStop(0, star.color);
                    gradient.addColorStop(0.7, star.color.replace('f', '7'));
                    gradient.addColorStop(1, 'rgba(255, 70, 0, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();

                    // 恒星核心
                    ctx.fillStyle = star.color;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            hitPlayer() {
                // 只有在飞船不处于无敌状态时才能被击中
                if (playerInvincible) return;

                // 减少生命值
                playerHealth -= 2;
                updateUI();

                // 创建碰撞效果
                createExplosion(
                    player.x + player.width/2,
                    player.y + player.height/2,
                    50, // 粒子数量
                    '#ff5' // 黄色
                );

                if (playerHealth <= 0) {
                    // 游戏结束
                    gameOver();
                    return;
                }

                // 设置飞船无敌状态
                playerInvincible = true;
                invincibleEndTime = performance.now() + 3000; // 3秒无敌时间

                // 将飞船传送到安全位置
                player.x = 100;
                player.y = GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2;
            }
        }

        // 水滴
        class Droplet {
            constructor() {
                this.width = 40;
                this.height = 60;
                this.x = GAME_WIDTH;
                this.y = GAME_HEIGHT / 2 - this.height / 2;
                this.speedX = -PLAYER_SPEED * 1.2; // 降低为飞船速度的1.2倍
                this.speedY = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.state = 'chase'; // chase, charge, lightning, stunned
                this.chargeTime = 0;
                this.cooldownCharge = 0;
                this.cooldownLightning = 0;
                this.lightning = null;
                this.stunnedTime = 0; // 停顿时间计数器
                this.chargeDirection = null; // 保存冲击方向和距离
                this.chargePaused = false; // 冲击后暂停状态
                this.chargePauseTime = 0; // 冲击后暂停时间计数器
            }

            update(deltaTime) {
                if (gameEnding) return;

                // 更新冷却时间
                if (this.cooldownCharge > 0) this.cooldownCharge -= deltaTime;
                if (this.cooldownLightning > 0) this.cooldownLightning -= deltaTime;

                // 状态机
                switch (this.state) {
                    case 'chase':
                        this.updateChase(deltaTime);
                        break;
                    case 'charge':
                        this.updateCharge(deltaTime);
                        break;
                    case 'lightning':
                        this.updateLightning(deltaTime);
                        break;
                    case 'stunned':
                        this.updateStunned(deltaTime);
                        break;
                }

                // 检查与飞船的碰撞
                if (this.checkCollision(player) && !playerInvincible && !godModeEnabled && this.state !== 'stunned') {
                    // 如果屏障激活，抵挡伤害
                    if (barrierActive) {
                        // 创建屏障抵挡效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            30,
                            '#0af' // 蓝色
                        );

                        // 只有在非无敌模式下才关闭屏障
                        if (!godModeEnabled) {
                            // 关闭屏障
                            barrierActive = false;

                            // 移除屏障技能图标
                            const barrierSkill = document.getElementById('barrierSkill');
                            if (barrierSkill) {
                                barrierSkill.remove();
                            }
                        }

                        // 水滴进入停顿状态
                        this.enterStunnedState();
                    } else {
                        playerHealth--;
                        updateUI();

                        // 创建碰撞效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            30,
                            '#aaa' // 银灰色
                        );

                        if (playerHealth <= 0) {
                            gameOver();
                            return;
                        }

                        // 设置飞船无敌状态
                        playerInvincible = true;
                        invincibleEndTime = performance.now() + 3000; // 3秒无敌时间

                        // 水滴进入停顿状态
                        this.enterStunnedState();
                    }
                }

                // 检查与障碍物的碰撞
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    // 跳过恒星、黑洞和白洞
                    if (obstacles[i].type >= 2) continue;

                    if (this.checkCollision(obstacles[i])) {
                        // 减少水滴生命值
                        dropletHealth--;

                        // 创建碰撞效果
                        createExplosion(
                            obstacles[i].x + obstacles[i].width/2,
                            obstacles[i].y + obstacles[i].height/2,
                            20,
                            '#aaa' // 银灰色
                        );

                        // 移除障碍物
                        obstacles.splice(i, 1);

                        // 检查水滴是否被摧毁
                        if (dropletHealth <= 0) {
                            this.destroy();
                            return;
                        }
                    }
                }
            }

            updateChase(deltaTime) {
                // 设置目标为飞船位置
                this.targetX = player.x;
                this.targetY = player.y;

                // 计算方向
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 缓慢转向飞船（模拟惯性）
                if (distance > 0) {
                    this.speedX = this.speedX * 0.95 + (dx / distance) * PLAYER_SPEED * 1.2 * 0.05;
                    this.speedY = this.speedY * 0.95 + (dy / distance) * PLAYER_SPEED * 1.2 * 0.05;
                }

                // 移动水滴
                this.x += this.speedX * deltaTime / 16;
                this.y += this.speedY * deltaTime / 16;

                // 保持在屏幕内
                if (this.x < 0) this.x = 0;
                if (this.x > GAME_WIDTH - this.width) this.x = GAME_WIDTH - this.width;
                if (this.y < 0) this.y = 0;
                if (this.y > GAME_HEIGHT - this.height) this.y = GAME_HEIGHT - this.height;

                // 随机切换到蓄力冲击状态
                if (this.cooldownCharge <= 0 && Math.random() < 0.005) {
                    this.state = 'charge';
                    this.chargeTime = 0;
                }

                // 随机切换到球状闪电状态
                if (this.cooldownLightning <= 0 && Math.random() < 0.002) {
                    this.state = 'lightning';
                    this.chargeTime = 0;
                }
            }

            updateCharge(deltaTime) {
                // 蓄力阶段
                this.chargeTime += deltaTime;

                if (this.chargeTime < 2000) {
                    // 蓄力中，减速
                    this.speedX *= 0.9;
                    this.speedY *= 0.9;
                } else if (!this.chargeDirection) {
                    // 蓄力完成，计算冲击方向（只计算一次）
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        // 保存冲击方向
                        this.chargeDirection = {
                            dirX: dx / distance,
                            dirY: dy / distance,
                            distanceTraveled: 0,
                            speed: PLAYER_SPEED * 2.17 // 增加30%速度（原来是1.67倍）
                        };
                    }
                } else if (!this.chargePaused) {
                    // 沿着固定方向冲击
                    const moveDistance = this.chargeDirection.speed * deltaTime / 16;
                    this.x += this.chargeDirection.dirX * moveDistance;
                    this.y += this.chargeDirection.dirY * moveDistance;
                    this.chargeDirection.distanceTraveled += moveDistance;

                    // 检查是否到达屏幕边缘
                    let hitBoundary = false;

                    if (this.x < 0) {
                        this.x = 0;
                        hitBoundary = true;
                    }
                    if (this.x > GAME_WIDTH - this.width) {
                        this.x = GAME_WIDTH - this.width;
                        hitBoundary = true;
                    }
                    if (this.y < 0) {
                        this.y = 0;
                        hitBoundary = true;
                    }
                    if (this.y > GAME_HEIGHT - this.height) {
                        this.y = GAME_HEIGHT - this.height;
                        hitBoundary = true;
                    }

                    // 如果到达屏幕边缘，进入暂停状态
                    if (hitBoundary) {
                        this.chargePaused = true;
                        this.chargePauseTime = 0;
                    }
                } else {
                    // 冲击后暂停3秒
                    this.chargePauseTime += deltaTime;

                    // 暂停结束，回到追逐状态
                    if (this.chargePauseTime >= 3000) {
                        this.state = 'chase';
                        this.cooldownCharge = 5000; // 5秒冷却
                        this.chargeDirection = null;
                        this.chargePaused = false;
                    }
                }
            }

            updateLightning(deltaTime) {
                // 蓄力阶段
                this.chargeTime += deltaTime;

                if (this.chargeTime < 2000) { // 减少蓄力时间，从3000ms改为2000ms
                    // 蓄力中，减速
                    this.speedX *= 0.9;
                    this.speedY *= 0.9;
                } else {
                    // 发射球状闪电
                    if (!this.lightning) {
                        // 总是向前方发射球状闪电
                        const dirX = -1; // 向左（玩家方向）发射
                        const dirY = 0;  // 不向上下偏移

                        this.lightning = {
                            x: this.x,
                            y: this.y + this.height/2,
                            size: 30,
                            initialSize: 30, // 初始大小
                            maxSize: 30 * 8, // 最大大小（8倍初始大小）
                            speedX: dirX * 4, // 更快的速度
                            speedY: dirY * 4,
                            exploded: false,
                            bolts: [],
                            creationTime: performance.now(), // 创建时间
                            lifeTime: 5000, // 5秒生命周期
                            linearBolts: [] // 新增：线状闪电
                        };

                        // 播放水滴攻击音效
                        if (dropletAttackSound) {
                            dropletAttackSound.currentTime = 0;
                            dropletAttackSound.play().catch(e => console.log("无法播放水滴攻击音效:", e));
                        }
                    }

                    // 更新球状闪电
                    this.lightning.x += this.lightning.speedX;
                    this.lightning.y += this.lightning.speedY;

                    // 检查与飞船的碰撞
                    const dx = this.lightning.x - (player.x + player.width/2);
                    const dy = this.lightning.y - (player.y + player.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.lightning.size + player.width/2 && !playerInvincible && !barrierActive) {
                        // 球状闪电击中飞船
                        playerHealth -= 2;
                        updateUI();

                        // 创建爆炸效果
                        createExplosion(
                            this.lightning.x,
                            this.lightning.y,
                            50,
                            '#0ff' // 青色
                        );

                        // 设置飞船无敌状态
                        playerInvincible = true;
                        invincibleEndTime = performance.now() + 3000; // 3秒无敌时间

                        // 将飞船弹到上边缘或下边缘
                        if (player.y < GAME_HEIGHT / 2) {
                            player.y = player.height;
                        } else {
                            player.y = GAME_HEIGHT - player.height * 2;
                        }

                        this.lightning.exploded = true;
                    } else if (distance < this.lightning.size + player.width/2 && barrierActive) {
                        // 如果屏障激活，创建屏障抵挡效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            30,
                            '#0af' // 蓝色
                        );

                        // 只有在非无敌模式下才关闭屏障
                        if (!godModeEnabled) {
                            // 关闭屏障
                            barrierActive = false;

                            // 移除屏障技能图标
                            const barrierSkill = document.getElementById('barrierSkill');
                            if (barrierSkill) {
                                barrierSkill.remove();
                            }
                        }

                        this.lightning.exploded = true;
                    }

                    // 检查与障碍物的碰撞
                    for (let obstacle of obstacles) {
                        if (obstacle.type <= 1) { // 只检查小行星和太空碎片
                            const dx = this.lightning.x - (obstacle.x + obstacle.width/2);
                            const dy = this.lightning.y - (obstacle.y + obstacle.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < this.lightning.size + obstacle.width/2) {
                                this.lightning.exploded = true;
                                break;
                            }
                        }
                    }

                    // 检查是否超出屏幕
                    if (this.lightning.x < 0 || this.lightning.x > GAME_WIDTH ||
                        this.lightning.y < 0 || this.lightning.y > GAME_HEIGHT) {
                        this.lightning.exploded = true;
                    }

                    // 检查生命周期
                    const currentTime = performance.now();
                    const elapsedTime = currentTime - this.lightning.creationTime;

                    // 根据生命周期调整大小，更快地增长到更大的尺寸
                    if (!this.lightning.exploded) {
                        const growthFactor = Math.min(1, elapsedTime / this.lightning.lifeTime);
                        this.lightning.size = this.lightning.initialSize +
                                             (this.lightning.maxSize - this.lightning.initialSize) * growthFactor;
                    }

                    // 如果超过生命周期，爆炸
                    if (elapsedTime >= this.lightning.lifeTime) {
                        this.lightning.exploded = true;
                    }

                    // 如果球状闪电爆炸
                    if (this.lightning.exploded) {
                        // 生成闪电束
                        if (this.lightning.bolts.length === 0) {
                            // 创建8个环形闪电束
                            for (let i = 0; i < 8; i++) {
                                const angle = i * Math.PI / 4;
                                this.lightning.bolts.push({
                                    x: this.lightning.x,
                                    y: this.lightning.y,
                                    angle: angle,
                                    length: 100 + Math.random() * 100,
                                    life: 1000
                                });
                            }

                            // 创建4个线状闪电，朝四个方向快速飞行
                            const directions = [
                                { x: -1, y: 0 },  // 左
                                { x: 1, y: 0 },   // 右
                                { x: 0, y: -1 },  // 上
                                { x: 0, y: 1 }    // 下
                            ];

                            for (let i = 0; i < 4; i++) {
                                this.lightning.linearBolts.push({
                                    x: this.lightning.x,
                                    y: this.lightning.y,
                                    dirX: directions[i].x,
                                    dirY: directions[i].y,
                                    speed: 10, // 快速移动
                                    width: 5,  // 闪电宽度
                                    length: 100, // 闪电长度
                                    active: true
                                });
                            }
                        }

                        // 更新环形闪电束
                        for (let i = this.lightning.bolts.length - 1; i >= 0; i--) {
                            const bolt = this.lightning.bolts[i];
                            bolt.life -= deltaTime;

                            // 检查与飞船的碰撞
                            const endX = bolt.x + Math.cos(bolt.angle) * bolt.length;
                            const endY = bolt.y + Math.sin(bolt.angle) * bolt.length;

                            // 简化的线段与圆形碰撞检测
                            const dx = player.x + player.width/2 - bolt.x;
                            const dy = player.y + player.height/2 - bolt.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < player.width && !playerInvincible && !barrierActive) {
                                playerHealth--;
                                updateUI();

                                // 创建碰撞效果
                                createExplosion(
                                    player.x + player.width/2,
                                    player.y + player.height/2,
                                    20,
                                    '#0ff' // 青色
                                );

                                if (playerHealth <= 0) {
                                    gameOver();
                                    return;
                                }

                                // 设置飞船无敌状态
                                playerInvincible = true;
                                invincibleEndTime = performance.now() + 3000; // 3秒无敌时间
                            } else if (dist < player.width && barrierActive) {
                                // 如果屏障激活，创建屏障抵挡效果
                                createExplosion(
                                    player.x + player.width/2,
                                    player.y + player.height/2,
                                    20,
                                    '#0af' // 蓝色
                                );

                                // 只有在非无敌模式下才关闭屏障
                                if (!godModeEnabled) {
                                    // 关闭屏障
                                    barrierActive = false;

                                    // 移除屏障技能图标
                                    const barrierSkill = document.getElementById('barrierSkill');
                                    if (barrierSkill) {
                                        barrierSkill.remove();
                                    }
                                }
                            }

                            // 移除生命结束的闪电束
                            if (bolt.life <= 0) {
                                this.lightning.bolts.splice(i, 1);
                            }
                        }

                        // 更新线状闪电
                        for (let i = this.lightning.linearBolts.length - 1; i >= 0; i--) {
                            const bolt = this.lightning.linearBolts[i];

                            // 移动线状闪电
                            bolt.x += bolt.dirX * bolt.speed;
                            bolt.y += bolt.dirY * bolt.speed;

                            // 检查是否超出屏幕
                            if (bolt.x < -bolt.length || bolt.x > GAME_WIDTH + bolt.length ||
                                bolt.y < -bolt.length || bolt.y > GAME_HEIGHT + bolt.length) {
                                bolt.active = false;
                            }

                            // 检查与飞船的碰撞
                            // 计算线段的起点和终点
                            const startX = bolt.x;
                            const startY = bolt.y;
                            const endX = bolt.x + bolt.dirX * bolt.length;
                            const endY = bolt.y + bolt.dirY * bolt.length;

                            // 计算飞船中心到线段的最短距离
                            const playerCenterX = player.x + player.width/2;
                            const playerCenterY = player.y + player.height/2;

                            // 简化的线段与圆形碰撞检测
                            const dx = playerCenterX - startX;
                            const dy = playerCenterY - startY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < player.width + bolt.width && bolt.active && !playerInvincible && !barrierActive) {
                                playerHealth--;
                                updateUI();

                                // 创建碰撞效果
                                createExplosion(
                                    playerCenterX,
                                    playerCenterY,
                                    20,
                                    '#0ff' // 青色
                                );

                                if (playerHealth <= 0) {
                                    gameOver();
                                    return;
                                }

                                // 设置飞船无敌状态
                                playerInvincible = true;
                                invincibleEndTime = performance.now() + 3000; // 3秒无敌时间

                                // 停用这条线状闪电
                                bolt.active = false;
                            } else if (dist < player.width + bolt.width && bolt.active && barrierActive) {
                                // 如果屏障激活，创建屏障抵挡效果
                                createExplosion(
                                    playerCenterX,
                                    playerCenterY,
                                    20,
                                    '#0af' // 蓝色
                                );

                                // 只有在非无敌模式下才关闭屏障
                                if (!godModeEnabled) {
                                    // 关闭屏障
                                    barrierActive = false;

                                    // 移除屏障技能图标
                                    const barrierSkill = document.getElementById('barrierSkill');
                                    if (barrierSkill) {
                                        barrierSkill.remove();
                                    }
                                }

                                // 停用这条线状闪电
                                bolt.active = false;
                            }
                        }

                        // 检查所有线状闪电是否都已经不活跃
                        const allLinearBoltsInactive = this.lightning.linearBolts.every(bolt => !bolt.active);

                        // 所有闪电束消失且所有线状闪电不活跃后，回到追逐状态
                        if (this.lightning.bolts.length === 0 && allLinearBoltsInactive) {
                            this.lightning = null;
                            this.state = 'chase';
                            this.cooldownLightning = 8000; // 8秒冷却（减少冷却时间）
                        }
                    }
                }
            }

            draw() {
                // 绘制水滴
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);

                // 水滴形状
                const gradient = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
                gradient.addColorStop(0, '#aaa'); // 银灰色
                gradient.addColorStop(0.5, '#ddd');
                gradient.addColorStop(1, '#888');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, -this.height/2);
                ctx.bezierCurveTo(
                    this.width/2, -this.height/3,
                    this.width/2, this.height/3,
                    0, this.height/2
                );
                ctx.bezierCurveTo(
                    -this.width/2, this.height/3,
                    -this.width/2, -this.height/3,
                    0, -this.height/2
                );
                ctx.fill();

                // 金属光泽
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-this.width/4, -this.height/4);
                ctx.lineTo(this.width/4, -this.height/4);
                ctx.stroke();

                ctx.restore();

                // 绘制状态效果
                switch (this.state) {
                    case 'stunned':
                        // 停顿效果 - 闪烁
                        if (Math.floor(this.stunnedTime / 100) % 2 === 0) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2,
                                    this.width/2 + 5, 0, Math.PI * 2);
                            ctx.stroke();

                            // 绘制小星星效果
                            for (let i = 0; i < 4; i++) {
                                const angle = this.stunnedTime / 100 + i * Math.PI / 2;
                                const distance = this.width/2 + 10;
                                const x = this.x + this.width/2 + Math.cos(angle) * distance;
                                const y = this.y + this.height/2 + Math.sin(angle) * distance;

                                ctx.fillStyle = '#fff';
                                ctx.beginPath();
                                ctx.arc(x, y, 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        break;
                    case 'charge':
                        if (this.chargeTime < 2000) {
                            // 蓄力效果 - 红色圆圈逐渐扩大
                            const chargeProgress = this.chargeTime / 2000;
                            ctx.strokeStyle = `rgba(255, 0, 0, ${chargeProgress})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2,
                                    this.width/2 + 10 * chargeProgress, 0, Math.PI * 2);
                            ctx.stroke();
                        } else if (this.chargePaused) {
                            // 暂停状态 - 只显示闪烁效果，不显示进度条
                            if (Math.floor(this.chargePauseTime / 300) % 2 === 0) {
                                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                                ctx.beginPath();
                                ctx.arc(this.x + this.width/2, this.y + this.height/2,
                                        this.width/2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        } else if (this.chargeDirection) {
                            // 冲击状态 - 显示运动轨迹
                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(this.x + this.width/2, this.y + this.height/2);
                            ctx.lineTo(
                                this.x + this.width/2 + this.chargeDirection.dirX * 30,
                                this.y + this.height/2 + this.chargeDirection.dirY * 30
                            );
                            ctx.stroke();
                        }
                        break;
                    case 'lightning':
                        // 蓄力效果
                        if (this.chargeTime < 2000) { // 减少蓄力时间，从3000ms改为2000ms
                            const chargeProgress = this.chargeTime / 2000;
                            ctx.strokeStyle = `rgba(0, 255, 255, ${chargeProgress})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2,
                                    this.width/2 + 15 * chargeProgress, 0, Math.PI * 2);
                            ctx.stroke();

                            // 添加电流效果
                            if (chargeProgress > 0.5) {
                                for (let i = 0; i < 6; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const length = this.width/2 * (0.5 + chargeProgress);

                                    ctx.strokeStyle = '#0ff';
                                    ctx.lineWidth = 1 + chargeProgress;
                                    ctx.beginPath();
                                    ctx.moveTo(this.x + this.width/2, this.y + this.height/2);
                                    ctx.lineTo(
                                        this.x + this.width/2 + Math.cos(angle) * length,
                                        this.y + this.height/2 + Math.sin(angle) * length
                                    );
                                    ctx.stroke();
                                }
                            }
                        } else if (this.lightning) {
                            // 绘制球状闪电
                            if (!this.lightning.exploded) {
                                // 闪电球 - 更明亮的颜色和发光效果
                                // 外部发光
                                const gradient = ctx.createRadialGradient(
                                    this.lightning.x, this.lightning.y, this.lightning.size * 0.5,
                                    this.lightning.x, this.lightning.y, this.lightning.size
                                );
                                gradient.addColorStop(0, '#0ff');
                                gradient.addColorStop(0.7, 'rgba(0, 255, 255, 0.7)');
                                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(this.lightning.x, this.lightning.y,
                                        this.lightning.size * 1.2, 0, Math.PI * 2);
                                ctx.fill();

                                // 内部核心
                                ctx.fillStyle = '#fff';
                                ctx.beginPath();
                                ctx.arc(this.lightning.x, this.lightning.y,
                                        this.lightning.size * 0.6, 0, Math.PI * 2);
                                ctx.fill();

                                // 闪电效果 - 更多的闪电
                                for (let i = 0; i < 8; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const length = this.lightning.size * 0.9;

                                    ctx.strokeStyle = '#fff';
                                    ctx.lineWidth = 2 + Math.random() * 2;
                                    ctx.beginPath();
                                    ctx.moveTo(this.lightning.x, this.lightning.y);

                                    // 绘制锯齿状闪电
                                    let currentLength = 0;
                                    let currentX = this.lightning.x;
                                    let currentY = this.lightning.y;

                                    while (currentLength < length) {
                                        const segmentLength = 5 + Math.random() * 10;
                                        const segmentAngle = angle + (Math.random() - 0.5) * 0.8;

                                        currentX += Math.cos(segmentAngle) * segmentLength;
                                        currentY += Math.sin(segmentAngle) * segmentLength;
                                        currentLength += segmentLength;

                                        ctx.lineTo(currentX, currentY);
                                    }

                                    ctx.stroke();
                                }
                            } else {
                                // 绘制环形闪电束
                                for (const bolt of this.lightning.bolts) {
                                    const alpha = bolt.life / 1000;

                                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                                    ctx.lineWidth = 3;
                                    ctx.beginPath();
                                    ctx.moveTo(bolt.x, bolt.y);

                                    // 绘制锯齿状闪电
                                    let currentLength = 0;
                                    let currentX = bolt.x;
                                    let currentY = bolt.y;

                                    while (currentLength < bolt.length) {
                                        const segmentLength = 10 + Math.random() * 20;
                                        const angle = bolt.angle + (Math.random() - 0.5) * 0.5;

                                        currentX += Math.cos(angle) * segmentLength;
                                        currentY += Math.sin(angle) * segmentLength;
                                        currentLength += segmentLength;

                                        ctx.lineTo(currentX, currentY);
                                    }

                                    ctx.stroke();
                                }

                                // 绘制线状闪电
                                for (const bolt of this.lightning.linearBolts) {
                                    if (!bolt.active) continue;

                                    // 绘制主闪电线
                                    ctx.strokeStyle = '#0ff';
                                    ctx.lineWidth = bolt.width;
                                    ctx.beginPath();

                                    // 绘制锯齿状闪电
                                    let currentLength = 0;
                                    let currentX = bolt.x;
                                    let currentY = bolt.y;
                                    ctx.moveTo(currentX, currentY);

                                    while (currentLength < bolt.length) {
                                        const segmentLength = 15 + Math.random() * 25;
                                        const angle = Math.atan2(bolt.dirY, bolt.dirX) + (Math.random() - 0.5) * 0.3;

                                        currentX += Math.cos(angle) * segmentLength;
                                        currentY += Math.sin(angle) * segmentLength;
                                        currentLength += segmentLength;

                                        ctx.lineTo(currentX, currentY);
                                    }

                                    ctx.stroke();

                                    // 绘制发光效果
                                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                                    ctx.lineWidth = bolt.width * 0.5;
                                    ctx.stroke();

                                    // 绘制分支闪电
                                    const branchCount = 2 + Math.floor(Math.random() * 3);
                                    for (let i = 0; i < branchCount; i++) {
                                        const startPos = Math.random();
                                        const branchX = bolt.x + bolt.dirX * bolt.length * startPos;
                                        const branchY = bolt.y + bolt.dirY * bolt.length * startPos;
                                        const branchAngle = Math.atan2(bolt.dirY, bolt.dirX) + (Math.random() - 0.5) * 1.5;
                                        const branchLength = bolt.length * 0.3;

                                        ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                                        ctx.lineWidth = bolt.width * 0.7;
                                        ctx.beginPath();
                                        ctx.moveTo(branchX, branchY);

                                        let bCurrentLength = 0;
                                        let bCurrentX = branchX;
                                        let bCurrentY = branchY;

                                        while (bCurrentLength < branchLength) {
                                            const segmentLength = 5 + Math.random() * 10;
                                            const angle = branchAngle + (Math.random() - 0.5) * 0.8;

                                            bCurrentX += Math.cos(angle) * segmentLength;
                                            bCurrentY += Math.sin(angle) * segmentLength;
                                            bCurrentLength += segmentLength;

                                            ctx.lineTo(bCurrentX, bCurrentY);
                                        }

                                        ctx.stroke();
                                    }
                                }
                            }
                        }
                        break;
                }

                // 绘制生命条
                const barWidth = 50;
                const barHeight = 6;
                const barX = this.x + this.width/2 - barWidth/2;
                const barY = this.y - 15;

                // 背景
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // 生命值
                const healthPercent = dropletHealth / 20;
                ctx.fillStyle = '#f00';
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
            }

            // 水滴进入停顿状态
            enterStunnedState() {
                // 保存当前状态以便恢复
                this.previousState = this.state;
                this.state = 'stunned';
                this.stunnedTime = 0;

                // 停止移动
                this.speedX = 0;
                this.speedY = 0;

                // 创建停顿效果
                createExplosion(
                    this.x + this.width/2,
                    this.y + this.height/2,
                    15,
                    '#fff' // 白色
                );
            }

            // 更新停顿状态
            updateStunned(deltaTime) {
                // 更新停顿时间
                this.stunnedTime += deltaTime;

                // 停顿1秒后恢复
                if (this.stunnedTime >= 1000) {
                    // 恢复到追逐状态，不再恢复到之前的状态
                    this.state = 'chase';

                    // 重置所有冲击相关的属性
                    this.chargeTime = 0;
                    this.chargeDirection = null;
                    this.chargePaused = false;
                    this.chargePauseTime = 0;

                    // 重置闪电相关的属性
                    if (this.lightning) {
                        this.lightning = null;
                    }
                }
            }

            checkCollision(entity) {
                // 简化的矩形碰撞检测
                return this.x < entity.x + entity.width &&
                       this.x + this.width > entity.x &&
                       this.y < entity.y + entity.height &&
                       this.y + this.height > entity.y;
            }

            destroy() {
                // 开始结束动画
                gameEnding = true;
                endingPhase = 0;
                endingTime = performance.now();

                // 停止所有音效
                if (collisionSound) collisionSound.pause();
                if (explosionSound) explosionSound.pause();
                if (energySound) energySound.pause();
                if (barrierSound) barrierSound.pause();
                if (wavegunSound) wavegunSound.pause();
                if (dropletAttackSound) dropletAttackSound.pause();

                // 停止背景音乐
                if (backgroundMusic) backgroundMusic.pause();
            }
        }

        // 粒子效果
        class Particle {
            constructor(x, y, color, speedMultiplier = 1) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.speedX = (Math.random() - 0.5) * 10 * speedMultiplier;
                this.speedY = (Math.random() - 0.5) * 10 * speedMultiplier;
                this.color = color;
                this.alpha = 1;
                this.decay = 0.01 + Math.random() * 0.03; // 粒子消失速度
                this.gravity = 0.1; // 粒子下落速度
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // 绘制菱形粒子 (类似Balatro风格)
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(this.size, 0);
                ctx.lineTo(0, this.size);
                ctx.lineTo(-this.size, 0);
                ctx.closePath();
                ctx.fill();

                // 绘制内部高光
                ctx.fillStyle = '#fff';
                const innerSize = this.size * 0.3;
                ctx.beginPath();
                ctx.moveTo(0, -innerSize);
                ctx.lineTo(innerSize, 0);
                ctx.lineTo(0, innerSize);
                ctx.lineTo(-innerSize, 0);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            update(deltaTime) {
                // 更新位置
                this.x += this.speedX;
                this.y += this.speedY;

                // 添加重力效果
                this.speedY += this.gravity;

                // 旋转
                this.rotation += this.rotationSpeed;

                // 减小透明度
                this.alpha -= this.decay;

                // 减小速度
                this.speedX *= 0.98;
                this.speedY *= 0.98;

                // 返回是否应该移除粒子
                return this.alpha <= 0;
            }
        }

        // 创建爆炸效果
        function createExplosion(x, y, count = 30, color = '#f70', playSound = true) {
            // 创建粒子
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, getCurrentSpeedMultiplier()));
            }

            // 如果游戏已经通关或正在结束，不播放音效
            if (gameEnding) {
                return;
            }

            // 根据颜色选择音效
            if (playSound) {
                let soundToPlay = null;

                if (color === '#f00') { // 红色爆炸 - 碰撞
                    soundToPlay = collisionSound;
                } else if (color === '#0af') { // 蓝色爆炸 - 屏障
                    soundToPlay = barrierSound;
                } else if (color === '#a0f') { // 紫色爆炸 - 次声波武器
                    soundToPlay = wavegunSound;
                } else if (color === '#0f0') { // 绿色爆炸 - 能量收集
                    soundToPlay = energySound;
                } else { // 默认爆炸
                    soundToPlay = explosionSound;
                }

                if (soundToPlay) {
                    soundToPlay.currentTime = 0;
                    soundToPlay.play().catch(e => console.log("音效播放失败:", e));
                }
            }
        }

        // 获取当前速度倍数
        function getCurrentSpeedMultiplier() {
            // 自动驾驶或切换过程中使用基础速度
            if (autopilotEnabled || autopilotTransitioning) {
                return 1.0;
            }
            return speedMultiplier;
        }

        // 开始自动驾驶切换过程
        function startAutopilotTransition(enable) {
            // 如果已经在切换中，不做任何事
            if (autopilotTransitioning) return;

            // 如果要开启自动驾驶但能量不足，不做任何事
            if (enable && playerEnergy <= 0) return;

            autopilotTransitioning = true;
            transitionProgress = 0;
            transitionDirection = enable ? 1 : -1;

            // 如果是关闭自动驾驶，立即设置状态但保持过渡动画
            if (!enable) {
                autopilotEnabled = false;
            }

            updateUI();
        }

        // 激活屏障
        function activateBarrier() {
            // 激活屏障
            if (hasBarrier && !barrierActive) {
                barrierActive = true;
                barrierEndTime = performance.now() + 15000; // 15秒持续时间

                // 创建屏障激活效果
                createExplosion(
                    player.x + player.width/2,
                    player.y + player.height/2,
                    30,
                    '#0af' // 蓝色
                );

                // 播放屏障激活音效
                if (barrierSound) {
                    barrierSound.currentTime = 0;
                    barrierSound.play().catch(e => console.log("无法播放屏障激活音效:", e));
                }
            }
        }

        // 关卡管理器
        class LevelManager {
            constructor() {
                this.currentLevelIndex = 0;
                this.progress = 0;
                this.distance = 0;
                this.isTransitioning = false;
                this.transitionProgress = 0;
                this.transitionTime = 3; // 过渡时间（秒）
            }

            getCurrentLevel() {
                return LEVELS[this.currentLevelIndex];
            }

            // 加载指定关卡
            loadLevel(levelIndex) {
                if (levelIndex >= 0 && levelIndex < LEVELS.length) {
                    this.currentLevelIndex = levelIndex;
                    this.progress = 0;
                    this.distance = 0;
                    this.isTransitioning = true;
                    this.transitionProgress = 0;

                    // 应用关卡设置
                    this.applyLevelSettings();

                    return true;
                }
                return false;
            }

            // 应用当前关卡设置
            applyLevelSettings() {
                const level = this.getCurrentLevel();

                // 设置背景星星数量
                stars = [];
                for (let i = 0; i < level.backgroundStars; i++) {
                    stars.push(new Star());
                }

                // 设置背景颜色
                document.body.style.backgroundColor = level.bgColor;

                // 第五关特殊处理：隐藏进度条
                if (level.id === 5) {
                    const progressBar = document.getElementById('levelProgress');
                    if (progressBar) {
                        progressBar.style.display = 'none';
                    }
                } else {
                    // 其他关卡显示进度条
                    const progressBar = document.getElementById('levelProgress');
                    if (progressBar) {
                        progressBar.style.display = 'block';
                    }
                }

                console.log(`应用关卡${level.id}设置: ${level.name}`);
            }

            updateProgress(deltaTime, speed) {
                // 如果正在过渡，更新过渡进度
                if (this.isTransitioning) {
                    this.transitionProgress += deltaTime / 1000 / this.transitionTime;
                    if (this.transitionProgress >= 1) {
                        this.isTransitioning = false;
                        this.transitionProgress = 0;
                    }
                    return;
                }

                // 获取当前关卡
                const level = this.getCurrentLevel();

                // 第五关特殊处理：只有水滴死亡才能过关，不显示进度条
                if (level.id === 5) {
                    // 隐藏进度条
                    const progressBar = document.getElementById('levelProgress');
                    if (progressBar && progressBar.style.display !== 'none') {
                        progressBar.style.display = 'none';
                    }

                    // 不通过得分完成关卡
                    return;
                }

                // 计算关卡进度 (基于得分)
                // 确保进度条严格与得分保持一致
                const newProgress = Math.min(gameScore / level.goalScore, 1);

                // 只有当进度有明显变化时才更新UI
                if (Math.abs(newProgress - this.progress) > 0.001) {
                    this.progress = newProgress;
                    // 更新进度条UI
                    document.getElementById('progressBar').style.width = `${Math.floor(this.progress * 100)}%`;
                }

                // 检查是否完成关卡 (确保进度完全达到1才完成)
                if (this.progress >= 0.999) {
                    this.completeLevel();
                }
            }

            completeLevel() {
                const level = this.getCurrentLevel();

                // 检查是否还有下一关
                if (this.currentLevelIndex < LEVELS.length - 1) {
                    // 创建关卡过渡效果
                    this.startLevelTransition();
                } else {
                    // 游戏通关
                    gameWin();
                }
            }

            // 开始关卡过渡
            startLevelTransition() {
                // 设置过渡状态
                this.isTransitioning = true;
                this.transitionProgress = 0;
                this.transitionTime = 5; // 过渡时间5秒

                // 清空障碍物和资源，创造空白区域
                obstacles = [];
                resources = [];

                // 重置游戏开始状态
                gameStarted = false;

                // 创建过渡动画
                setTimeout(() => {
                    // 过渡结束后，加载下一关
                    this.currentLevelIndex++;
                    this.progress = 0;
                    this.distance = 0;

                    // 重置手动驾驶时间，使速度从新关卡的初始值开始
                    manualDriveTime = 0;

                    // 恢复生命值和能量值
                    playerHealth = MAX_HEALTH;
                    playerEnergy = MAX_ENERGY;

                    // 根据新关卡设置初始速度
                    const newLevel = this.getCurrentLevel();
                    // 关卡1：初始1.0，最高2.0
                    // 关卡2：初始1.5，最高3.0
                    // 关卡3：初始2.0，最高4.0
                    // 关卡4+：初始2.5，最高4.0（宇宙坍缩速度上限）
                    speedMultiplier = Math.min(1.0 + (newLevel.id - 1) * 0.5, MAX_UNIVERSE_SPEED - 1.5); // 每关初始速度增加0.5，但不超过上限
                    console.log(`关卡${newLevel.id}初始速度: ${speedMultiplier.toFixed(1)}x (最大: ${Math.min(2.0 + (newLevel.id - 1) * 1.0, MAX_UNIVERSE_SPEED).toFixed(1)}x)`);

                    // 应用新关卡设置
                    this.applyLevelSettings();

                    // 更新UI
                    updateUI();
                }, this.transitionTime * 1000);
            }

            drawTransition(ctx) {
                if (!this.isTransitioning) return;

                const progress = this.transitionProgress;

                // 获取当前关卡
                const currentLevel = this.getCurrentLevel();

                // 如果是游戏开始时的第一关，不显示"关卡完成"信息
                const isFirstLevelStart = this.currentLevelIndex === 0 && gameScore === 0;

                // 获取下一关卡（如果有）
                const nextLevelIndex = Math.min(this.currentLevelIndex + 1, LEVELS.length - 1);
                const nextLevel = isFirstLevelStart ? currentLevel : LEVELS[nextLevelIndex];

                // 过渡阶段：0-0.2 淡出当前关卡进度条，0.2-0.8 显示下一关信息，0.8-1.0 淡入下一关
                if (progress < 0.2) {
                    // 阶段1：淡出当前关卡进度条
                    const fadeOutProgress = progress / 0.2;

                    // 绘制淡出效果
                    ctx.fillStyle = `rgba(0, 0, 0, ${fadeOutProgress * 0.7})`;
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                    // 只有在不是游戏开始的第一关时才显示"关卡完成"信息
                    if (!isFirstLevelStart) {
                        // 显示当前关卡完成信息
                        ctx.fillStyle = `rgba(0, 255, 0, ${1 - fadeOutProgress})`;
                        ctx.font = '36px "Courier New", Courier, monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(`关卡 ${currentLevel.id} 完成!`, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);

                        ctx.fillStyle = `rgba(255, 255, 255, ${1 - fadeOutProgress})`;
                        ctx.font = '24px "Courier New", Courier, monospace';
                        ctx.fillText(`得分: ${Math.floor(gameScore)}`, GAME_WIDTH / 2, GAME_HEIGHT / 2);
                    }

                } else if (progress < 0.8) {
                    // 阶段2：显示下一关信息
                    const midProgress = (progress - 0.2) / 0.6;
                    const textOpacity = midProgress < 0.5 ? midProgress * 2 : 2 - midProgress * 2;

                    // 绘制黑色背景
                    ctx.fillStyle = `rgba(0, 0, 0, 0.7)`;
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                    // 显示下一关信息
                    ctx.fillStyle = `rgba(0, 170, 255, ${textOpacity})`;
                    ctx.font = '36px "Courier New", Courier, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`第 ${nextLevel.id} 关: ${nextLevel.name}`, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);

                    // 绘制关卡描述
                    ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`;
                    ctx.font = '16px "Courier New", Courier, monospace';

                    // 处理中文文本换行
                    const maxWidth = GAME_WIDTH * 0.8;
                    const text = nextLevel.description;
                    let line = '';
                    let y = GAME_HEIGHT / 2 + 20;

                    // 逐字检查宽度，适合中文文本
                    for (let i = 0; i < text.length; i++) {
                        const testLine = line + text[i];
                        const metrics = ctx.measureText(testLine);

                        if (metrics.width > maxWidth && line.length > 0) {
                            ctx.fillText(line, GAME_WIDTH / 2, y);
                            line = text[i];
                            y += 24; // 行间距
                        } else {
                            line = testLine;
                        }
                    }

                    // 绘制最后一行
                    if (line.length > 0) {
                        ctx.fillText(line, GAME_WIDTH / 2, y);
                    }

                } else {
                    // 阶段3：淡入下一关
                    const fadeInProgress = (progress - 0.8) / 0.2;

                    // 绘制淡入效果
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * (1 - fadeInProgress)})`;
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                }
            }
        }

        // 创建开始界面的星星背景
        function createStartScreenStars() {
            const startScreen = document.getElementById('startScreen');
            const starCount = 100;

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.width = `${Math.random() * 3 + 1}px`;
                star.style.height = star.style.width;
                star.style.opacity = Math.random();
                star.style.animationDuration = `${Math.random() * 3 + 2}s`;

                // 添加闪烁动画
                star.style.animation = `twinkle ${Math.random() * 5 + 3}s infinite alternate`;
                startScreen.appendChild(star);
            }
        }

        // 初始化游戏
        function init() {
            // 创建开始界面的星星
            createStartScreenStars();

            // 获取游戏画布
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // 设置canvas尺寸与游戏逻辑尺寸一致
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // 加载音效
            loadSounds();

            // 初始化关卡管理器
            levelManager = new LevelManager();

            // 创建星星背景
            for (let i = 0; i < 100; i++) {
                stars.push(new Star());
            }

            // 事件监听
            window.addEventListener('keydown', function(e) {
                keys[e.key] = true;

                // 空格键切换自动驾驶
                if (e.key === ' ' && gameRunning && !autopilotTransitioning && !levelManager.isTransitioning) {
                    if (!autopilotEnabled && playerEnergy > 0) {
                        startAutopilotTransition(true);
                    } else if (autopilotEnabled) {
                        startAutopilotTransition(false);
                    }
                }

                // Q键使用屏障
                if ((e.key === 'q' || e.key === 'Q') && gameRunning && hasBarrier && !barrierActive) {
                    activateBarrier();
                }

                // W键使用次声波武器
                if ((e.key === 'w' || e.key === 'W') && gameRunning && hasWavegun) {
                    fireWavegun();
                }

                // I键切换无敌模式（隐藏功能）
                if ((e.key === 'i' || e.key === 'I') && gameRunning) {
                    godModeEnabled = !godModeEnabled;

                    // 如果开启无敌模式，确保屏障激活
                    if (godModeEnabled) {
                        if (!barrierActive) {
                            // 添加屏障技能图标（如果不存在）
                            if (!document.getElementById('barrierSkill')) {
                                const skillIcon = document.createElement('div');
                                skillIcon.id = 'barrierSkill';
                                skillIcon.style.position = 'absolute';
                                skillIcon.style.bottom = '10px';
                                skillIcon.style.left = '10px';
                                skillIcon.style.width = '40px';
                                skillIcon.style.height = '40px';
                                skillIcon.style.backgroundColor = 'rgba(0, 170, 255, 0.3)';
                                skillIcon.style.border = '2px solid #0af';
                                skillIcon.style.borderRadius = '5px';
                                skillIcon.style.display = 'flex';
                                skillIcon.style.justifyContent = 'center';
                                skillIcon.style.alignItems = 'center';
                                skillIcon.style.color = '#fff';
                                skillIcon.style.fontSize = '12px';
                                skillIcon.style.fontWeight = 'bold';
                                skillIcon.innerHTML = 'Q<br>护盾';

                                // 将图标添加到游戏容器
                                document.getElementById('gameContainer').appendChild(skillIcon);
                            }

                            // 激活屏障
                            barrierActive = true;
                            hasBarrier = true;

                            // 创建屏障激活效果
                            createExplosion(
                                player.x + player.width/2,
                                player.y + player.height/2,
                                30,
                                '#0af' // 蓝色
                            );
                        }
                    } else {
                        // 如果关闭无敌模式，关闭屏障
                        if (barrierActive) {
                            barrierActive = false;

                            // 移除屏障技能图标
                            const barrierSkill = document.getElementById('barrierSkill');
                            if (barrierSkill) {
                                barrierSkill.remove();
                            }
                        }
                    }

                    console.log(`无敌模式: ${godModeEnabled ? '开启' : '关闭'}`);
                }

                // ESC键关闭游戏说明
                if (e.key === 'Escape') {
                    document.getElementById('instructionsModal').style.display = 'none';
                }
            });

            window.addEventListener('keyup', function(e) {
                keys[e.key] = false;
            });

            // 按钮事件
            document.getElementById('startButton').addEventListener('click', function() {
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'block';

                // 直接在用户点击时播放背景音乐
                if (backgroundMusic) {
                    backgroundMusic.currentTime = 0;
                    backgroundMusic.play().catch(e => console.log("点击开始游戏时无法播放背景音乐:", e));
                }

                startGame();
            });

            // 游戏说明按钮
            document.getElementById('instructionsButton').addEventListener('click', function() {
                document.getElementById('instructionsModal').style.display = 'flex';
            });

            // 关闭游戏说明按钮
            document.getElementById('closeInstructions').addEventListener('click', function() {
                document.getElementById('instructionsModal').style.display = 'none';
            });

            // 重新开始按钮
            document.getElementById('restartButton').addEventListener('click', function() {
                restartGame();
            });

            // 初始UI更新
            updateUI();
        }

        // 开始游戏
        function startGame() {
            console.log("开始游戏...");

            gameRunning = true;
            gameScore = 0;
            gameTime = 0;
            manualDriveTime = 0;
            speedMultiplier = 1.0;
            playerHealth = MAX_HEALTH;
            playerEnergy = MAX_ENERGY;
            autopilotEnabled = false;
            autopilotTransitioning = false;
            obstacles = [];
            resources = [];
            stars = [];
            player.x = 100;
            player.y = GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2;

            // 确保canvas尺寸与游戏逻辑尺寸一致
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // 重置关卡管理器并加载第一关
            console.log("初始化关卡管理器...");
            levelManager = new LevelManager();
            levelManager.loadLevel(0);

            // 重新创建星星背景
            console.log("创建星星背景...");
            for (let i = 0; i < 100; i++) {
                stars.push(new Star());
            }

            // 确保游戏容器显示
            document.getElementById('gameContainer').style.display = 'block';

            console.log("启动游戏循环...");
            lastTime = performance.now();
            lastEnergyDrainTime = performance.now(); // 重置能量消耗计时器
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // 格式化时间为分:秒格式
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // 更新UI
        function updateUI() {
            document.getElementById('score').textContent = '得分: ' + Math.floor(gameScore);

            // 如果有其他UI元素，更新它们
            if (document.getElementById('health')) {
                let healthBar = '';
                for (let i = 0; i < MAX_HEALTH; i++) {
                    healthBar += i < playerHealth ? '■' : '□';
                }
                document.getElementById('health').textContent = '生命值: ' + healthBar;
            }

            if (document.getElementById('energy')) {
                let energyBar = '';
                for (let i = 0; i < MAX_ENERGY; i++) {
                    energyBar += i < playerEnergy ? '■' : '□';
                }
                document.getElementById('energy').textContent = '能量: ' + energyBar;
            }

            if (document.getElementById('autopilot')) {
                let autopilotStatus = autopilotEnabled ? '开启' : '关闭';
                if (autopilotTransitioning) {
                    autopilotStatus = transitionDirection > 0 ? '正在开启...' : '正在关闭...';
                }
                document.getElementById('autopilot').textContent = '自动驾驶: ' + autopilotStatus;
            }

            // 游戏时间在游戏循环中单独更新，这里不再更新
            // 这样可以确保游戏时间每秒更新一次

            if (document.getElementById('speedMultiplier')) {
                document.getElementById('speedMultiplier').textContent = '速度: ' + speedMultiplier.toFixed(1) + 'x';
            }

            // 更新关卡信息
            const level = levelManager.getCurrentLevel();
            const progressPercent = Math.floor(levelManager.progress * 100);

            document.getElementById('levelInfo').textContent =
                `第${level.id}关: ${level.name} - 目标: ${level.goalScore}分`;

            document.getElementById('progressBar').style.width = `${progressPercent}%`;

            // 更新屏障技能图标
            const barrierSkill = document.getElementById('barrierSkill');
            if (barrierSkill) {
                if (barrierActive) {
                    barrierSkill.style.backgroundColor = 'rgba(0, 170, 255, 0.7)';
                    barrierSkill.style.boxShadow = '0 0 10px #0af';
                } else {
                    barrierSkill.style.backgroundColor = 'rgba(0, 170, 255, 0.3)';
                    barrierSkill.style.boxShadow = 'none';
                }
            }

            // 更新次声波武器技能图标
            const wavegunSkill = document.getElementById('wavegunSkill');
            if (wavegunSkill && !hasWavegun) {
                wavegunSkill.remove();
            }
        }

        // 激活屏障
        function activateBarrier() {
            if (!hasBarrier || barrierActive) return;

            barrierActive = true;
            barrierEndTime = performance.now() + 15000; // 15秒持续时间
            hasBarrier = false; // 使用后消耗道具

            // 更新UI
            updateUI();

            // 创建屏障激活效果
            createExplosion(
                player.x + player.width/2,
                player.y + player.height/2,
                30,
                '#0af' // 蓝色
            );

            // 15秒后自动关闭屏障
            setTimeout(function() {
                if (barrierActive) {
                    barrierActive = false;

                    // 移除屏障技能图标
                    const barrierSkill = document.getElementById('barrierSkill');
                    if (barrierSkill) {
                        barrierSkill.remove();
                    }

                    // 创建屏障消失效果
                    createExplosion(
                        player.x + player.width/2,
                        player.y + player.height/2,
                        20,
                        '#0af' // 蓝色
                    );
                }
            }, 15000);
        }

        // 使用次声波武器
        function fireWavegun() {
            if (!hasWavegun) return;

            // 消耗道具
            hasWavegun = false;

            // 播放次声波武器音效
            if (wavegunSound) {
                wavegunSound.currentTime = 0;
                wavegunSound.play().catch(e => console.log("无法播放次声波武器音效:", e));
            }

            // 移除次声波武器技能图标
            const wavegunSkill = document.getElementById('wavegunSkill');
            if (wavegunSkill) {
                wavegunSkill.remove();
            }

            // 创建次声波效果 - 从飞船向外扩散的圆形波
            const waveEffect = {
                x: player.x + player.width/2,
                y: player.y + player.height/2,
                radius: 0,
                maxRadius: Math.max(GAME_WIDTH, GAME_HEIGHT),
                speed: 15,
                alpha: 1
            };

            // 动画函数
            function animateWave() {
                // 增加半径
                waveEffect.radius += waveEffect.speed;

                // 绘制波
                ctx.save();
                ctx.strokeStyle = `rgba(170, 0, 255, ${waveEffect.alpha})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(waveEffect.x, waveEffect.y, waveEffect.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                // 检查与障碍物的碰撞
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    // 跳过恒星、黑洞和白洞
                    if (obstacles[i].type >= 2) continue;

                    // 计算障碍物中心到波源的距离
                    const dx = (obstacles[i].x + obstacles[i].width/2) - waveEffect.x;
                    const dy = (obstacles[i].y + obstacles[i].height/2) - waveEffect.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // 如果障碍物在波的范围内且尚未被摧毁
                    if (distance <= waveEffect.radius && distance >= waveEffect.radius - waveEffect.speed) {
                        // 创建爆炸效果
                        createExplosion(
                            obstacles[i].x + obstacles[i].width/2,
                            obstacles[i].y + obstacles[i].height/2,
                            20,
                            '#a0f' // 紫色
                        );

                        // 移除障碍物
                        obstacles.splice(i, 1);

                        // 增加分数
                        gameScore += 100;
                    }
                }

                // 检查与水滴的碰撞（如果存在）
                if (droplet && !gameEnding) {
                    // 计算水滴中心到波源的距离
                    const dx = (droplet.x + droplet.width/2) - waveEffect.x;
                    const dy = (droplet.y + droplet.height/2) - waveEffect.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // 如果水滴在波的范围内
                    if (distance <= waveEffect.radius && distance >= waveEffect.radius - waveEffect.speed) {
                        // 对水滴造成2点伤害
                        dropletHealth -= 2;

                        // 创建爆炸效果
                        createExplosion(
                            droplet.x + droplet.width/2,
                            droplet.y + droplet.height/2,
                            30,
                            '#a0f' // 紫色
                        );

                        // 检查水滴是否被摧毁
                        if (dropletHealth <= 0) {
                            droplet.destroy();
                        }
                    }
                }

                // 减小透明度
                waveEffect.alpha = Math.max(0, 1 - waveEffect.radius / waveEffect.maxRadius);

                // 如果波还没有达到最大半径，继续动画
                if (waveEffect.radius < waveEffect.maxRadius) {
                    requestAnimationFrame(animateWave);
                }
            }

            // 开始动画
            animateWave();
        }

        // 绘制屏障
        function drawBarrier() {
            if (!barrierActive) return;

            // 检查屏障是否已过期
            if (performance.now() > barrierEndTime) {
                barrierActive = false;

                // 移除屏障技能图标
                const barrierSkill = document.getElementById('barrierSkill');
                if (barrierSkill) {
                    barrierSkill.remove();
                }

                return;
            }

            // 计算屏障剩余时间比例
            const timeLeft = (barrierEndTime - performance.now()) / 15000;

            // 绘制屏障效果
            ctx.save();

            // 创建径向渐变
            const gradient = ctx.createRadialGradient(
                player.x + player.width/2, player.y + player.height/2, player.width/2,
                player.x + player.width/2, player.y + player.height/2, player.width * 1.5
            );

            gradient.addColorStop(0, 'rgba(0, 170, 255, 0.1)');
            gradient.addColorStop(0.7, 'rgba(0, 170, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 170, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(
                player.x + player.width/2,
                player.y + player.height/2,
                player.width * 1.5,
                0,
                Math.PI * 2
            );
            ctx.fill();

            // 绘制屏障边缘
            ctx.strokeStyle = `rgba(0, 170, 255, ${0.5 + Math.sin(performance.now() / 100) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(
                player.x + player.width/2,
                player.y + player.height/2,
                player.width * 1.5,
                0,
                Math.PI * 2
            );
            ctx.stroke();

            // 绘制剩余时间指示器
            ctx.strokeStyle = '#0af';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(
                player.x + player.width/2,
                player.y + player.height/2,
                player.width * 1.5,
                -Math.PI/2,
                -Math.PI/2 + Math.PI * 2 * timeLeft
            );
            ctx.stroke();

            ctx.restore();
        }

        // 游戏主循环
        function gameLoop(timestamp) {
            if (!gameRunning) {
                console.log("游戏未运行，跳过游戏循环");
                return;
            }

            // 第一帧时输出调试信息
            if (!window.gameLoopStarted) {
                console.log("游戏循环开始执行...");
                window.gameLoopStarted = true;
            }

            // 计算时间差
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // 更新游戏时间 (无论自动驾驶状态如何，都计算真实时间)
            // 使用固定的时间增量，确保时间显示均匀
            const timeIncrement = 1/60; // 假设游戏以60FPS运行

            // 记录上一秒的游戏时间，用于检测是否过了一秒
            const prevGameTimeSeconds = Math.floor(gameTime);

            gameTime += timeIncrement;

            // 检查是否过了一秒，如果是，更新游戏时间显示
            const currentGameTimeSeconds = Math.floor(gameTime);
            if (currentGameTimeSeconds > prevGameTimeSeconds) {
                // 只更新游戏时间显示，不更新其他UI
                if (document.getElementById('gameTime')) {
                    document.getElementById('gameTime').textContent = '游戏时间: ' + formatTime(gameTime);
                }
            }

            // 只在手动驾驶时累计手动驾驶时间
            if (!autopilotEnabled && !autopilotTransitioning) {
                manualDriveTime += timeIncrement;
            }

            // 定时消耗能量（每2秒减少1格，关卡过渡时不消耗，游戏真正开始后才消耗）
            if (!levelManager.isTransitioning && timestamp - lastEnergyDrainTime >= ENERGY_DRAIN_INTERVAL) {
                if (playerEnergy > 0) {
                    playerEnergy -= 1;
                    updateUI();
                }
                lastEnergyDrainTime = timestamp;

                // 获取当前关卡
                const currentLevel = levelManager.getCurrentLevel();

                // 根据关卡设置初始和最大速度
                // 关卡1：初始1.0，最高2.0
                // 关卡2：初始1.5，最高3.0
                // 关卡3：初始2.0，最高4.0
                // 关卡4+：初始2.5，最高4.0（宇宙坍缩速度上限）
                const initialSpeed = Math.min(1.0 + (currentLevel.id - 1) * 0.5, MAX_UNIVERSE_SPEED - 1.5); // 每关初始速度增加0.5
                const maxSpeedMultiplier = Math.min(2.0 + (currentLevel.id - 1) * 1.0, MAX_UNIVERSE_SPEED); // 每关最大速度增加1.0，但不超过宇宙坍缩速度上限

                // 计算新的速度倍数
                const speedRange = maxSpeedMultiplier - initialSpeed;
                const newSpeedMultiplier = initialSpeed + Math.min(
                    Math.floor(manualDriveTime / SPEED_INCREASE_INTERVAL) * SPEED_INCREASE_AMOUNT,
                    speedRange
                );

                if (newSpeedMultiplier !== speedMultiplier) {
                    speedMultiplier = newSpeedMultiplier;
                    updateUI();
                    console.log(`速度更新: ${speedMultiplier.toFixed(1)}x (最大: ${maxSpeedMultiplier}x)`);
                }
            }

            // 更新关卡进度
            if (levelManager) {
                levelManager.updateProgress(deltaTime, getCurrentSpeedMultiplier());
            }

            // 清空画布
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // 更新和绘制星星
            for (let star of stars) {
                star.update(deltaTime);
                star.draw();
            }

            // 如果关卡正在过渡，不生成新的障碍物和资源
            if (levelManager && !levelManager.isTransitioning) {
                const level = levelManager.getCurrentLevel();

                // 生成障碍物
                if (Math.random() < level.obstacleRate * getCurrentSpeedMultiplier()) {
                    obstacles.push(new Obstacle());
                }

                // 生成能量资源 (前两关降低生成率，第三关及以后保持标准生成率)
                let energyRate = level.resourceRate.energy;
                if (level.id <= 2) {
                    energyRate *= 0.7; // 前两关降低30%生成率
                }
                if (Math.random() < energyRate * getCurrentSpeedMultiplier()) {
                    resources.push(new Resource(0)); // 0 = 能量
                }

                // 生成生命资源
                if (Math.random() < level.resourceRate.health * getCurrentSpeedMultiplier()) {
                    resources.push(new Resource(1)); // 1 = 生命
                }

                // 生成屏障道具 (真正的1%概率，不受速度影响，第二关之后才出现)
                if (Math.random() < 0.001 && level.id >= 2) {
                    resources.push(new Resource(2)); // 2 = 屏障
                }

                // 生成次声波武器 (真正的1%概率，不受速度影响，第二关之后才出现)
                if (Math.random() < 0.001 && level.id >= 2) {
                    resources.push(new Resource(3)); // 3 = 次声波武器
                }

                // 检查游戏是否真正开始（飞船是否超过第一个障碍物）
                if (!gameStarted && obstacles.length > 0) {
                    // 找到最前面的障碍物
                    const firstObstacle = obstacles.reduce((closest, current) => {
                        return (closest.x < current.x) ? closest : current;
                    }, obstacles[0]);

                    // 如果飞船超过了第一个障碍物，游戏真正开始
                    if (player.x + player.width > firstObstacle.x) {
                        gameStarted = true;
                        console.log("游戏真正开始！");
                    }
                }
            }

            // 更新和绘制障碍物
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const isOutOfScreen = obstacles[i].update(deltaTime);

                // 检查碰撞 - 只在游戏未结束时检测
                if (!gameEnding && obstacles[i].checkCollision(player) && !playerInvincible && !godModeEnabled) {
                    // 如果是黑洞，让黑洞自己处理碰撞
                    if (obstacles[i].type === 3) {
                        continue;
                    }

                    // 如果屏障激活，抵挡伤害
                    if (barrierActive) {
                        // 创建屏障抵挡效果
                        const collisionX = (player.x + player.width/2 + obstacles[i].x + obstacles[i].width/2) / 2;
                        const collisionY = (player.y + player.height/2 + obstacles[i].y + obstacles[i].height/2) / 2;

                        createExplosion(
                            collisionX,
                            collisionY,
                            30,
                            '#0af' // 蓝色
                        );

                        // 移除障碍物
                        obstacles.splice(i, 1);

                        // 只有在非无敌模式下才关闭屏障
                        if (!godModeEnabled) {
                            // 关闭屏障
                            barrierActive = false;

                            // 移除屏障技能图标
                            const barrierSkill = document.getElementById('barrierSkill');
                            if (barrierSkill) {
                                barrierSkill.remove();
                            }
                        }

                        continue;
                    }

                    playerHealth--;
                    updateUI();

                    // 创建爆炸效果
                    const collisionX = (player.x + player.width/2 + obstacles[i].x + obstacles[i].width/2) / 2;
                    const collisionY = (player.y + player.height/2 + obstacles[i].y + obstacles[i].height/2) / 2;

                    // 根据障碍物类型选择爆炸颜色
                    let explosionColor;
                    switch(obstacles[i].type) {
                        case 0: explosionColor = '#a87'; break; // 小行星
                        case 1: explosionColor = '#888'; break; // 太空碎片
                        case 2: explosionColor = '#f70'; break; // 恒星
                        default: explosionColor = '#f70';
                    }

                    // 创建爆炸，粒子数量与障碍物大小成正比
                    createExplosion(
                        collisionX,
                        collisionY,
                        20 + obstacles[i].sizeMultiplier * 10,
                        explosionColor
                    );

                    // 播放碰撞音效
                    if (collisionSound) {
                        collisionSound.currentTime = 0;
                        collisionSound.play().catch(e => console.log("无法播放碰撞音效:", e));
                    }

                    obstacles.splice(i, 1);

                    if (playerHealth <= 0) {
                        // 游戏结束，创建更大的爆炸
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            100, // 更多粒子
                            '#f00' // 红色爆炸
                        );

                        gameOver();
                        return;
                    }

                    // 设置飞船无敌状态
                    playerInvincible = true;
                    invincibleEndTime = performance.now() + 3000; // 3秒无敌时间

                    continue;
                }

                // 如果超出屏幕或被标记为移除则移除
                if (isOutOfScreen || obstacles[i].markedForRemoval) {
                    obstacles.splice(i, 1);
                    continue;
                }

                obstacles[i].draw();
            }

            // 更新和绘制资源
            for (let i = resources.length - 1; i >= 0; i--) {
                const isOutOfScreen = resources[i].update(deltaTime);

                // 检查碰撞 - 只在游戏未结束时检测
                if (!gameEnding && resources[i].checkCollision(player)) {
                    if (resources[i].type === 0) {
                        // 能量晶体
                        playerEnergy = Math.min(MAX_ENERGY, playerEnergy + 2); // 补充2格能量
                        // 能量晶体得分：200分
                        gameScore += 200;

                        // 创建拾取效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            10,
                            '#0f0' // 绿色
                        );

                        // 播放能量收集音效
                        if (energySound) {
                            energySound.currentTime = 0;
                            energySound.play().catch(e => console.log("无法播放能量收集音效:", e));
                        }
                    } else if (resources[i].type === 1) {
                        // 生命修复
                        playerHealth = Math.min(MAX_HEALTH, playerHealth + 1);
                        // 生命修复得分：500分
                        gameScore += 500;

                        // 创建拾取效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            10,
                            '#f00' // 红色
                        );
                    } else if (resources[i].type === 2) {
                        // 屏障道具
                        hasBarrier = true;
                        gameScore += 300;

                        // 创建拾取效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            15,
                            '#0af' // 蓝色
                        );

                        // 添加屏障技能图标到UI
                        if (!document.getElementById('barrierSkill')) {
                            const skillIcon = document.createElement('div');
                            skillIcon.id = 'barrierSkill';
                            skillIcon.style.position = 'absolute';
                            skillIcon.style.bottom = '10px';
                            skillIcon.style.left = '10px';
                            skillIcon.style.width = '40px';
                            skillIcon.style.height = '40px';
                            skillIcon.style.backgroundColor = 'rgba(0, 170, 255, 0.3)';
                            skillIcon.style.border = '2px solid #0af';
                            skillIcon.style.borderRadius = '5px';
                            skillIcon.style.display = 'flex';
                            skillIcon.style.justifyContent = 'center';
                            skillIcon.style.alignItems = 'center';
                            skillIcon.style.color = '#fff';
                            skillIcon.style.fontSize = '12px';
                            skillIcon.style.fontWeight = 'bold';
                            skillIcon.innerHTML = 'Q<br>护盾';

                            // 将图标添加到游戏容器而不是body
                            document.getElementById('gameContainer').appendChild(skillIcon);
                        }
                    } else if (resources[i].type === 3) {
                        // 次声波武器
                        hasWavegun = true;
                        gameScore += 300;

                        // 创建拾取效果
                        createExplosion(
                            player.x + player.width/2,
                            player.y + player.height/2,
                            15,
                            '#a0f' // 紫色
                        );

                        // 添加次声波武器技能图标到UI
                        if (!document.getElementById('wavegunSkill')) {
                            const skillIcon = document.createElement('div');
                            skillIcon.id = 'wavegunSkill';
                            skillIcon.style.position = 'absolute';
                            skillIcon.style.bottom = '10px';
                            skillIcon.style.left = '60px';
                            skillIcon.style.width = '40px';
                            skillIcon.style.height = '40px';
                            skillIcon.style.backgroundColor = 'rgba(170, 0, 255, 0.3)';
                            skillIcon.style.border = '2px solid #a0f';
                            skillIcon.style.borderRadius = '5px';
                            skillIcon.style.display = 'flex';
                            skillIcon.style.justifyContent = 'center';
                            skillIcon.style.alignItems = 'center';
                            skillIcon.style.color = '#fff';
                            skillIcon.style.fontSize = '12px';
                            skillIcon.style.fontWeight = 'bold';
                            skillIcon.innerHTML = 'W<br>声波';

                            // 将图标添加到游戏容器而不是body
                            document.getElementById('gameContainer').appendChild(skillIcon);
                        }
                    }
                    updateUI();
                    resources.splice(i, 1);
                    continue;
                }

                // 如果超出屏幕则移除
                if (isOutOfScreen) {
                    resources.splice(i, 1);
                    continue;
                }

                resources[i].draw();
            }

            // 更新和绘制粒子
            for (let i = particles.length - 1; i >= 0; i--) {
                const shouldRemove = particles[i].update(deltaTime);
                if (shouldRemove) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw();
                }
            }

            // 更新和绘制玩家
            player.update(deltaTime);
            player.draw();

            // 绘制屏障（如果激活）
            if (barrierActive) {
                drawBarrier();
            }

            // 更新得分 (基于存活时间，手动驾驶得分更高)
            if (gameStarted && !levelManager.isTransitioning) {
                // 基础得分：每秒增加关卡目标分数的0.5%
                const level = levelManager.getCurrentLevel();
                const baseScoreIncrement = level.goalScore * 0.005 * (deltaTime / 1000);

                if (autopilotEnabled || autopilotTransitioning) {
                    // 自动驾驶时得分减半
                    gameScore += baseScoreIncrement * 0.5;
                } else {
                    // 手动驾驶得分翻倍
                    gameScore += baseScoreIncrement * 1.0;
                }
            }

            // 每秒更新一次UI
            if (Math.floor(timestamp / 1000) !== Math.floor(lastTime / 1000)) {
                updateUI();
            }

            // 处理关卡5特殊元素
            if (levelManager && levelManager.getCurrentLevel().id === 5) {
                // 创建三体星系
                if (!trisolaris) {
                    trisolaris = new Trisolaris();
                }

                // 更新和绘制三体星系
                trisolaris.update(deltaTime);
                trisolaris.draw();

                // 10秒后生成水滴
                if (!dropletSpawned && gameTime > 10) {
                    droplet = new Droplet();
                    dropletSpawned = true;
                    dropletSpawnTime = gameTime;

                    // 固定游戏速度为3倍
                    speedMultiplier = 3.0;

                    // 在UI底部添加水滴生命条
                    const dropletHealthBar = document.createElement('div');
                    dropletHealthBar.id = 'dropletHealthBar';
                    dropletHealthBar.style.position = 'absolute';
                    dropletHealthBar.style.bottom = '10px';
                    dropletHealthBar.style.left = '50%';
                    dropletHealthBar.style.transform = 'translateX(-50%)';
                    dropletHealthBar.style.width = '300px';
                    dropletHealthBar.style.height = '20px';
                    dropletHealthBar.style.backgroundColor = '#333';
                    dropletHealthBar.style.border = '2px solid #555';
                    dropletHealthBar.style.borderRadius = '5px';
                    dropletHealthBar.style.overflow = 'hidden';

                    const dropletHealthFill = document.createElement('div');
                    dropletHealthFill.id = 'dropletHealthFill';
                    dropletHealthFill.style.width = '100%';
                    dropletHealthFill.style.height = '100%';
                    dropletHealthFill.style.backgroundColor = '#f00';
                    dropletHealthFill.style.transition = 'width 0.3s';

                    dropletHealthBar.appendChild(dropletHealthFill);
                    document.getElementById('gameContainer').appendChild(dropletHealthBar);
                }

                // 更新和绘制水滴
                if (droplet) {
                    droplet.update(deltaTime);
                    droplet.draw();

                    // 更新水滴生命条
                    const healthFill = document.getElementById('dropletHealthFill');
                    if (healthFill) {
                        healthFill.style.width = (dropletHealth / 20 * 100) + '%';
                    }
                }
            }

            // 如果关卡正在过渡，绘制过渡效果
            if (levelManager && levelManager.isTransitioning) {
                levelManager.drawTransition(ctx);
            }

            // 如果游戏结束动画正在播放
            if (gameEnding) {
                drawEnding();
            }

            // 继续游戏循环
            requestAnimationFrame(gameLoop);
        }

        // 游戏结束
        function gameOver() {
            gameRunning = false;

            // 显示游戏结束界面
            const gameOverScreen = document.getElementById('gameOverScreen');
            document.getElementById('finalScoreValue').textContent = Math.floor(gameScore);
            gameOverScreen.style.display = 'flex';
        }

        // 重新开始游戏
        function restartGame() {
            // 重置所有游戏状态
            gameScore = 0;
            gameTime = 0;
            manualDriveTime = 0;
            speedMultiplier = 1.0;
            playerHealth = MAX_HEALTH;
            playerEnergy = MAX_ENERGY;
            autopilotEnabled = false;
            autopilotTransitioning = false;
            obstacles = [];
            resources = [];
            particles = [];
            gameStarted = false; // 重置游戏开始状态
            player.x = 100;
            player.y = GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2;

            // 确保canvas尺寸与游戏逻辑尺寸一致
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // 重置关卡5特殊元素
            trisolaris = null;
            droplet = null;
            dropletHealth = 20;
            dropletSpawned = false;
            gameEnding = false;

            // 重置道具状态
            hasBarrier = false;
            hasWavegun = false;

            // 播放背景音乐
            if (backgroundMusic) {
                backgroundMusic.currentTime = 0;
                backgroundMusic.play().catch(e => console.log("重新开始游戏时无法播放背景音乐:", e));
            }
            barrierActive = false;

            // 移除水滴生命条
            const dropletHealthBar = document.getElementById('dropletHealthBar');
            if (dropletHealthBar) {
                dropletHealthBar.remove();
            }

            // 移除技能图标
            const barrierSkill = document.getElementById('barrierSkill');
            if (barrierSkill) {
                barrierSkill.remove();
            }

            const wavegunSkill = document.getElementById('wavegunSkill');
            if (wavegunSkill) {
                wavegunSkill.remove();
            }

            // 重置关卡管理器并加载第一关
            levelManager = new LevelManager();
            levelManager.loadLevel(0); // 确保从第一关开始

            // 隐藏游戏结束界面
            document.getElementById('gameOverScreen').style.display = 'none';

            // 重置能量消耗计时器
            lastEnergyDrainTime = performance.now();

            // 开始游戏
            gameRunning = true;
            lastTime = performance.now();
            updateUI();

            // 播放背景音乐
            if (backgroundMusic) {
                // 确保音乐从头开始播放
                backgroundMusic.currentTime = 0;

                // 尝试播放背景音乐
                const playPromise = backgroundMusic.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log("背景音乐播放成功");
                    }).catch(e => {
                        console.log("无法自动播放背景音乐:", e);
                        // 添加点击事件监听器，在用户交互后播放音乐
                        document.addEventListener('click', function playOnClick() {
                            backgroundMusic.currentTime = 0;
                            backgroundMusic.play();
                            document.removeEventListener('click', playOnClick);
                            console.log("用户交互后播放背景音乐");
                        }, { once: true });
                    });
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // 游戏通关
        function gameWin() {
            // 如果是第五关或者游戏结束动画正在播放，不显示通关界面
            if (gameEnding || (levelManager && levelManager.getCurrentLevel().id === 5)) {
                return;
            }

            gameRunning = false;

            // 显示游戏通关界面
            const gameOverScreen = document.getElementById('gameOverScreen');
            document.getElementById('finalScoreValue').textContent = Math.floor(gameScore);
            document.querySelector('.gameOverText').textContent = '恭喜！你成功逃离了银河系！';
            document.querySelector('.gameOverText').style.color = '#0af';
            document.querySelector('.gameOverText').style.textShadow = '0 0 10px #0af';
            gameOverScreen.style.display = 'flex';
        }

        // 绘制结束动画
        function drawEnding() {
            if (!gameEnding) return;

            const currentTime = performance.now();
            const elapsedTime = currentTime - endingTime;

            // 阶段0：水滴爆炸前的闪烁，游戏减速
            if (endingPhase === 0) {
                // 减缓游戏速度至初始倍速
                const slowdownFactor = Math.max(1.0, 3.0 - (elapsedTime / 3000) * 2.0);
                speedMultiplier = slowdownFactor;

                // 设置玩家无敌状态，防止生命值降低
                playerInvincible = true;
                invincibleEndTime = Infinity; // 永久无敌

                // 水滴闪烁
                if (Math.floor(elapsedTime / 200) % 2 === 0) {
                    // 绘制水滴
                    ctx.save();
                    ctx.translate(droplet.x + droplet.width/2, droplet.y + droplet.height/2);

                    // 水滴形状
                    const gradient = ctx.createLinearGradient(-droplet.width/2, -droplet.height/2, droplet.width/2, droplet.height/2);
                    gradient.addColorStop(0, '#fff'); // 变成白色
                    gradient.addColorStop(0.5, '#fff');
                    gradient.addColorStop(1, '#ddd');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -droplet.height/2);
                    ctx.bezierCurveTo(
                        droplet.width/2, -droplet.height/3,
                        droplet.width/2, droplet.height/3,
                        0, droplet.height/2
                    );
                    ctx.bezierCurveTo(
                        -droplet.width/2, droplet.height/3,
                        -droplet.width/2, -droplet.height/3,
                        0, -droplet.height/2
                    );
                    ctx.fill();

                    ctx.restore();
                }

                // 3秒后进入下一阶段
                if (elapsedTime > 3000) {
                    endingPhase = 1;
                    endingTime = currentTime;

                    // 清空所有游戏元素
                    obstacles = [];
                    resources = [];
                    trisolaris = null;
                    droplet = null;

                    // 停止背景音乐
                    if (backgroundMusic) {
                        backgroundMusic.pause();
                        backgroundMusic.currentTime = 0;
                    }

                    // 播放水滴爆炸音效 - 重复三次，每次间隔半秒
                    if (dropletExplosionSound) {
                        // 第一次播放
                        dropletExplosionSound.currentTime = 0;
                        dropletExplosionSound.play().catch(e => console.log("无法播放水滴爆炸音效(第1次):", e));

                        // 半秒后播放第二次
                        setTimeout(() => {
                            dropletExplosionSound.currentTime = 0;
                            dropletExplosionSound.play().catch(e => console.log("无法播放水滴爆炸音效(第2次):", e));

                            // 再半秒后播放第三次
                            setTimeout(() => {
                                dropletExplosionSound.currentTime = 0;
                                dropletExplosionSound.play().catch(e => console.log("无法播放水滴爆炸音效(第3次):", e));
                            }, 500);
                        }, 500);
                    }
                }
            }
            // 阶段1：水滴爆炸，白光扩散
            else if (endingPhase === 1) {
                // 清空画布
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // 只绘制星星背景
                for (let star of stars) {
                    star.update(16);
                    star.draw();
                }

                const explosionProgress = Math.min(1, elapsedTime / 2000);
                const explosionRadius = explosionProgress * Math.max(GAME_WIDTH, GAME_HEIGHT) * 1.5;

                // 绘制白色爆炸
                const gradient = ctx.createRadialGradient(
                    GAME_WIDTH / 2, GAME_HEIGHT / 2, 0,
                    GAME_WIDTH / 2, GAME_HEIGHT / 2, explosionRadius
                );
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // 2秒后进入下一阶段
                if (elapsedTime > 2000) {
                    endingPhase = 2;
                    endingTime = currentTime;
                }
            }
            // 阶段2：保持白色画面3秒
            else if (endingPhase === 2) {
                // 清空画布
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // 只绘制星星背景
                for (let star of stars) {
                    star.update(16);
                    star.draw();
                }

                // 保持白色画面
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // 3秒后进入下一阶段
                if (elapsedTime > 3000) {
                    endingPhase = 3;
                    endingTime = currentTime;

                    // 重新播放背景音乐
                    if (backgroundMusic) {
                        backgroundMusic.currentTime = 0;
                        backgroundMusic.play().catch(e => console.log("无法播放背景音乐:", e));
                    }
                }
            }
            // 阶段3：白光消失，露出太空背景和飞船
            else if (endingPhase === 3) {
                // 清空画布
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // 只绘制星星背景
                for (let star of stars) {
                    star.update(16);
                    star.draw();
                }

                const fadeOutProgress = Math.min(1, elapsedTime / 3000);

                // 白光淡出效果
                const whiteAlpha = Math.max(0, 1 - fadeOutProgress * 2); // 1.5秒内淡出
                if (whiteAlpha > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${whiteAlpha})`;
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                }

                // 飞船从左侧移动到中央
                const shipProgress = Math.min(1, fadeOutProgress * 1.5); // 2秒内移动到中央
                const shipX = shipProgress * (GAME_WIDTH / 2 - PLAYER_WIDTH / 2);
                const shipY = GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2;

                // 绘制像素风格的飞船
                ctx.fillStyle = '#0af';

                // 飞船主体
                ctx.fillRect(shipX + 20, shipY + 20, 30, 20);

                // 飞船头部
                ctx.fillRect(shipX + 50, shipY + 25, 10, 10);

                // 飞船尾部
                ctx.fillRect(shipX + 10, shipY + 15, 10, 30);

                // 飞船引擎
                ctx.fillStyle = '#f70';
                ctx.fillRect(shipX, shipY + 20, 10, 5);
                ctx.fillRect(shipX, shipY + 35, 10, 5);

                // 飞船窗口
                ctx.fillStyle = '#fff';
                ctx.fillRect(shipX + 35, shipY + 25, 5, 10);

                // 如果白光已经完全消失，显示祝贺文字
                if (fadeOutProgress > 0.7) {
                    const textAlpha = Math.min(1, (fadeOutProgress - 0.7) / 0.3);

                    // 从下往上浮现文字
                    const baseY = GAME_HEIGHT - (GAME_HEIGHT * 0.3) * (fadeOutProgress - 0.7) / 0.3;

                    // 祝贺文字
                    ctx.fillStyle = `rgba(255, 255, 255, ${textAlpha})`;
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('祝贺您已成功逃离银河系', GAME_WIDTH / 2, baseY);
                    ctx.fillText('请前往新世界建立新的文明', GAME_WIDTH / 2, baseY + 40);

                    // 开发者名单
                    if (fadeOutProgress > 0.85) {
                        const creditAlpha = Math.min(1, (fadeOutProgress - 0.85) / 0.15);
                        ctx.fillStyle = `rgba(200, 200, 200, ${creditAlpha})`;
                        ctx.font = '16px Arial';
                        ctx.fillText('游戏设计：Klein Wang', GAME_WIDTH / 2, baseY + 100);
                        ctx.fillText('美术：Klein Wang', GAME_WIDTH / 2, baseY + 130);
                        ctx.fillText('游戏开发：Klein Wang', GAME_WIDTH / 2, baseY + 160);

                        // 再玩一次按钮
                        const buttonWidth = 120;
                        const buttonHeight = 40;
                        const buttonX = GAME_WIDTH - buttonWidth - 20;
                        const buttonY = GAME_HEIGHT - buttonHeight - 20;

                        ctx.fillStyle = `rgba(0, 170, 255, ${creditAlpha})`;
                        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

                        ctx.fillStyle = `rgba(255, 255, 255, ${creditAlpha})`;
                        ctx.font = '18px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('再玩一次', buttonX + buttonWidth / 2, buttonY + buttonHeight / 2 + 6);

                        // 添加点击事件监听
                        if (!endingButtonAdded && fadeOutProgress >= 1) {
                            const restartButton = document.createElement('div');
                            restartButton.style.position = 'absolute';
                            restartButton.style.width = buttonWidth + 'px';
                            restartButton.style.height = buttonHeight + 'px';
                            restartButton.style.left = buttonX + 'px';
                            restartButton.style.top = buttonY + 'px';
                            restartButton.style.backgroundColor = 'rgba(0, 0, 0, 0)'; // 透明背景
                            restartButton.style.cursor = 'pointer';
                            restartButton.style.zIndex = '1000';

                            restartButton.onclick = function() {
                                location.reload();
                            };

                            document.getElementById('gameContainer').appendChild(restartButton);
                            endingButtonAdded = true;
                        }
                    }
                }

                // 不再进入下一阶段，保持这个画面
            }
            // 阶段4：显示祝贺文字
            else if (endingPhase === 4) {
                // 绘制飞船在空白宇宙中
                const shipX = GAME_WIDTH * 0.4;
                const shipY = GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2;

                // 绘制像素风格的飞船
                ctx.fillStyle = '#0af';

                // 飞船主体
                ctx.fillRect(shipX + 20, shipY + 20, 30, 20);

                // 飞船头部
                ctx.fillRect(shipX + 50, shipY + 25, 10, 10);

                // 飞船尾部
                ctx.fillRect(shipX + 10, shipY + 15, 10, 30);

                // 飞船引擎
                ctx.fillStyle = '#f70';
                ctx.fillRect(shipX, shipY + 20, 10, 5);
                ctx.fillRect(shipX, shipY + 35, 10, 5);

                // 飞船窗口
                ctx.fillStyle = '#fff';
                ctx.fillRect(shipX + 35, shipY + 25, 5, 10);

                // 显示祝贺文字
                const textProgress = Math.min(1, elapsedTime / 2000);

                if (textProgress >= 1) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '24px "Courier New", Courier, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText("祝贺您已成功逃离银河系，请前往新世界建立新的文明。", GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);

                    // 5秒后进入下一阶段
                    if (elapsedTime > 7000) {
                        endingPhase = 4;
                        endingTime = currentTime;
                    }
                }
            }
            // 阶段4：显示开发者名单
            else if (endingPhase === 4) {
                // 绘制飞船在空白宇宙中
                const shipX = GAME_WIDTH * 0.4;
                const shipY = GAME_HEIGHT / 2 - PLAYER_HEIGHT / 2;

                // 绘制像素风格的飞船
                ctx.fillStyle = '#0af';

                // 飞船主体
                ctx.fillRect(shipX + 20, shipY + 20, 30, 20);

                // 飞船头部
                ctx.fillRect(shipX + 50, shipY + 25, 10, 10);

                // 飞船尾部
                ctx.fillRect(shipX + 10, shipY + 15, 10, 30);

                // 飞船引擎
                ctx.fillStyle = '#f70';
                ctx.fillRect(shipX, shipY + 20, 10, 5);
                ctx.fillRect(shipX, shipY + 35, 10, 5);

                // 飞船窗口
                ctx.fillStyle = '#fff';
                ctx.fillRect(shipX + 35, shipY + 25, 5, 10);

                // 显示开发者名单
                const scrollProgress = Math.min(1, elapsedTime / 10000);
                const startY = GAME_HEIGHT + 50 - scrollProgress * (GAME_HEIGHT + 200);

                ctx.fillStyle = '#fff';
                ctx.font = '20px "Courier New", Courier, monospace';
                ctx.textAlign = 'center';

                ctx.fillText("游戏设计：Klein Wang", GAME_WIDTH / 2, startY);
                ctx.fillText("美术：Klein Wang", GAME_WIDTH / 2, startY + 40);
                ctx.fillText("游戏开发：Klein Wang", GAME_WIDTH / 2, startY + 80);

                // 显示"再玩一次"按钮
                if (elapsedTime > 5000) {
                    // 定义按钮尺寸和位置
                    const buttonWidth = 120;
                    const buttonHeight = 40;
                    const buttonX = GAME_WIDTH - buttonWidth - 20;
                    const buttonY = GAME_HEIGHT - buttonHeight - 20;

                    // 绘制按钮背景
                    ctx.fillStyle = '#0af';
                    ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

                    // 绘制按钮文字
                    ctx.fillStyle = '#fff';
                    ctx.font = '18px "Courier New", Courier, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText("再玩一次", buttonX + buttonWidth / 2, buttonY + buttonHeight / 2 + 6);

                    // 添加点击事件
                    if (!window.endingClickHandler) {
                        window.endingClickHandler = true;
                        canvas.addEventListener('click', function(e) {
                            if (gameEnding && endingPhase === 4 && elapsedTime > 5000) {
                                const rect = canvas.getBoundingClientRect();
                                const x = e.clientX - rect.left;
                                const y = e.clientY - rect.top;

                                // 检查是否点击了"再玩一次"按钮
                                if (x > buttonX && x < buttonX + buttonWidth &&
                                    y > buttonY && y < buttonY + buttonHeight) {
                                    restartGame();
                                }
                            }
                        });
                    }
                }
            }
        }

        // 加载游戏音效
        function loadSounds() {
            try {
                // 创建碰撞音效 - 短促的碰撞声
                collisionSound = new Audio();
                collisionSound.src = 'https://www.fesliyanstudios.com/play-mp3/6699';
                collisionSound.volume = 0.2; // 降低音量

                // 预加载音效
                collisionSound.load();

                // 创建背景音乐 - 蓝色多瑙河
                backgroundMusic = new Audio();
                backgroundMusic.src = 'blue-danube.mp3'; // 使用本地文件
                backgroundMusic.loop = true; // 循环播放
                backgroundMusic.volume = 0.2; // 设置音量

                // 创建其他音效
                // 爆炸音效 - 短促的爆炸声
                explosionSound = new Audio();
                explosionSound.src = 'https://www.fesliyanstudios.com/play-mp3/6705';
                explosionSound.volume = 0.2; // 降低音量

                // 能量收集音效 - 短促的收集声
                energySound = new Audio();
                energySound.src = 'https://www.fesliyanstudios.com/play-mp3/6728';
                energySound.volume = 0.2;

                // 屏障激活音效 - 短促的激活声
                barrierSound = new Audio();
                barrierSound.src = 'https://www.fesliyanstudios.com/play-mp3/6717';
                barrierSound.volume = 0.2;

                // 次声波武器音效 - 短促的激光声
                wavegunSound = new Audio();
                wavegunSound.src = 'https://www.fesliyanstudios.com/play-mp3/6708';
                wavegunSound.volume = 0.2;

                // 水滴攻击音效 - 短促的电击声
                dropletAttackSound = new Audio();
                dropletAttackSound.src = 'https://www.fesliyanstudios.com/play-mp3/6707';
                dropletAttackSound.volume = 0.2;

                // 水滴爆炸音效 - 更宏大的爆炸声，带有延长的尾音
                dropletExplosionSound = new Audio();
                dropletExplosionSound.src = 'https://www.fesliyanstudios.com/play-mp3/6703'; // 更换为更宏大的爆炸音效
                dropletExplosionSound.volume = 0.5; // 增大音量，使其更加宏大

                // 预加载所有音效
                backgroundMusic.load();
                explosionSound.load();
                energySound.load();
                barrierSound.load();
                wavegunSound.load();
                dropletAttackSound.load();
                dropletExplosionSound.load();

                console.log("音效加载成功");
            } catch (error) {
                console.error("加载音效时出错:", error);
            }
        }

        // 添加星星闪烁动画
        const style = document.createElement('style');
        style.textContent = `
            @keyframes twinkle {
                0% { opacity: 0.3; }
                100% { opacity: 1; }
            }
        `;
        document.head.appendChild(style);

        // 初始化游戏
        window.addEventListener('load', init);
    </script>
</body>
</html>
